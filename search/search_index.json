{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Programming \u00b6 The 3DC Introduction to Programming is a series of workshops that introduce basic but crucial programming concepts to complete beginners who are keen to enter the world of computer science/ software engineering. In addition, this workshop also prepares you for the first-year programming module (Computational Thinking for Design) at SUTD, give you a great head start. By the end of this workshop series, you should be capable of building and deploying your own simple applications, and more importantly, you will have a great starting point to self-learn anything in the world of programming. Early-Mats round time period: 26 Jan 2021 to 09 Feb 2021 . Sign up now! Session details as follows. Day 1: Introduction to programming with Python \u00b6 Date: 26 Jan 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to Programming Introduction to Command Line Python Programming Hands-on: Simple Python Project Day 2: Introduction to Git & GitHub, Python Continued \u00b6 Date: 28 Jan 2021 (Thursday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to version management tools - Git & GitHub Python Programming Hands-on: Simple Python Project Day 3: Introduction to Web Technologies and Web Scrapping \u00b6 Date: 02 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to Frontend, Backend technologies Introduction to HTTP protocols Introduction to the Python Requests Library Introduction to Web Scrapping Hands-on: Simple Web Scrapping Day 4: Introduction to Web Development with Flask \u00b6 Date: 04 Feb 2021 (Thursday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to API Introduction to Flask Introduction to Json Introduction to Firebase Day 5: Introduction to Linux & Shell \u00b6 Date: 09 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction Linux Introduction to UNIX Shell Introduction to SSH Introduction to Dotfiles Management","title":"Overview"},{"location":"#introduction-to-programming","text":"The 3DC Introduction to Programming is a series of workshops that introduce basic but crucial programming concepts to complete beginners who are keen to enter the world of computer science/ software engineering. In addition, this workshop also prepares you for the first-year programming module (Computational Thinking for Design) at SUTD, give you a great head start. By the end of this workshop series, you should be capable of building and deploying your own simple applications, and more importantly, you will have a great starting point to self-learn anything in the world of programming. Early-Mats round time period: 26 Jan 2021 to 09 Feb 2021 . Sign up now! Session details as follows.","title":"Introduction to Programming"},{"location":"#day-1-introduction-to-programming-with-python","text":"Date: 26 Jan 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to Programming Introduction to Command Line Python Programming Hands-on: Simple Python Project","title":"Day 1: Introduction to programming with Python"},{"location":"#day-2-introduction-to-git-github-python-continued","text":"Date: 28 Jan 2021 (Thursday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to version management tools - Git & GitHub Python Programming Hands-on: Simple Python Project","title":"Day 2: Introduction to Git &amp; GitHub, Python Continued"},{"location":"#day-3-introduction-to-web-technologies-and-web-scrapping","text":"Date: 02 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to Frontend, Backend technologies Introduction to HTTP protocols Introduction to the Python Requests Library Introduction to Web Scrapping Hands-on: Simple Web Scrapping","title":"Day 3: Introduction to Web Technologies and Web Scrapping"},{"location":"#day-4-introduction-to-web-development-with-flask","text":"Date: 04 Feb 2021 (Thursday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction to API Introduction to Flask Introduction to Json Introduction to Firebase","title":"Day 4: Introduction to Web Development with Flask"},{"location":"#day-5-introduction-to-linux-shell","text":"Date: 09 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction Linux Introduction to UNIX Shell Introduction to SSH Introduction to Dotfiles Management","title":"Day 5: Introduction to Linux &amp; Shell"},{"location":"Day_0/install_git/","text":"How to Install & Configure Git \u00b6 For Windows User \u00b6 You will need to install Git Bash for Windows . Just follow the installation instructions on the page and choose the default settings. For macOS User \u00b6 Open Terminal app on your macOS. Just copy and paste the following command in your terminal , then hit enter key, to check your git version, it will prompt you to install Git if you haven't already. git --version For Linux (Ubuntu/Debian) User \u00b6 Check Git Installation git --version If it is not already installed, use the following command in shell / terminal sudo apt install git-all For Linux (Fedora) User \u00b6 Check Git Installation git --version If it is not already installed, use the following command in shell / terminal sudo yum install git Configure Git \u00b6 From now onwards, the commands used in this workshop will be done in a terminal window (Windows: Git Bash, macOS: Terminal or whatever shell, Linux: Bash or whatever shell) Setting up Git username and email address \u00b6 Just letting Git know who you are. If you already have a GitHub account, keep the email address for your Git at local same as your GitHub email address. To check current username and email address for Git. It returns nothing if no name/email has been set. git config --global user.name git config --global user.email To set username and email address for Git. --global means to set for all the repositories on your machine. If you only want to set for a single repository, do it without the --global flag. git config --global user.name \"Tom Cruise\" git config --global user.email \"tom@example.com\" Reference: - Getting Started - Installing Git","title":"Install Git"},{"location":"Day_0/install_git/#how-to-install-configure-git","text":"","title":"How to Install &amp; Configure Git"},{"location":"Day_0/install_git/#for-windows-user","text":"You will need to install Git Bash for Windows . Just follow the installation instructions on the page and choose the default settings.","title":"For Windows User"},{"location":"Day_0/install_git/#for-macos-user","text":"Open Terminal app on your macOS. Just copy and paste the following command in your terminal , then hit enter key, to check your git version, it will prompt you to install Git if you haven't already. git --version","title":"For macOS User"},{"location":"Day_0/install_git/#for-linux-ubuntudebian-user","text":"Check Git Installation git --version If it is not already installed, use the following command in shell / terminal sudo apt install git-all","title":"For Linux (Ubuntu/Debian) User"},{"location":"Day_0/install_git/#for-linux-fedora-user","text":"Check Git Installation git --version If it is not already installed, use the following command in shell / terminal sudo yum install git","title":"For Linux (Fedora) User"},{"location":"Day_0/install_git/#configure-git","text":"From now onwards, the commands used in this workshop will be done in a terminal window (Windows: Git Bash, macOS: Terminal or whatever shell, Linux: Bash or whatever shell)","title":"Configure Git"},{"location":"Day_0/install_git/#setting-up-git-username-and-email-address","text":"Just letting Git know who you are. If you already have a GitHub account, keep the email address for your Git at local same as your GitHub email address. To check current username and email address for Git. It returns nothing if no name/email has been set. git config --global user.name git config --global user.email To set username and email address for Git. --global means to set for all the repositories on your machine. If you only want to set for a single repository, do it without the --global flag. git config --global user.name \"Tom Cruise\" git config --global user.email \"tom@example.com\" Reference: - Getting Started - Installing Git","title":"Setting up Git username and email address"},{"location":"Day_0/install_python_mac/","text":"How to Install Vanilla Python on macOS Properly? \u00b6 Note at the beginning \u00b6 Warning Do NOT remove Apple-supplied system Python 2.7.x (whatever version that is), as it may break the whole operating system. What is a Vanilla Install? Vanilla Install simply means not customized from their original form . What is Anaconda Python? Anaconda is a open-source Python distribution. It aims to provide everything you need (Python-wise) for data science \"out of the box\". It includes: The core Python language 100+ Python \"packages\" (libraries) Spyder IDE and Jupyter Notebook conda, Anaconda's own package manager, used for updating Anaconda and packages Reference: Matthias Braun If you think the following guide is overwhelming for you, Anaconda is a good choice for beginners, just head over to Anaconda distribution , choose Python 3.X for your operating system, download and install it, and you are good to go. Vanilla Install Python \u00b6 What to be installed: Homebrew : a package manager targeted at macOS. Similar to Apt for Linux. Pip : a package manager for the python world, installing python packages with pip will fetch packages from the Python Package Index . Python 3.7.X Step 0: Remove existing 3 rd party Python \u00b6 Step 0.1 \u00b6 Open Finder, Navigate to /Applications , delete any folder named Python 2.X or Python 3.X . Step 0.2 \u00b6 Open Finder, go to your main Drive, usually Macintosh HD Use Finder, navigate to /Library/Frameworks/Python.framework/Versions/ Delete everything within /Versions folder. Alternatively, if you know what version of Python do you have, let say 3.6, you can use the following command in the Terminal. sudo rm -rf /Library/Frameworks/Python.framework/Versions/3.6 Step 0.3 \u00b6 Remove all the symbolic links in /usr/local/bin that point to Python related files: sudo rm /usr/local/bin/python* sudo rm /usr/local/bin/pip* Step 1: Install Homebrew \u00b6 Open Terminal on your Mac and paste in the following command and hit Enter. /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Step 2: Install Python using Homewbrew \u00b6 Type this in Terminal and hit Enter. brew install python Homebrew will install Pip as well. Step 3: Change Environment Variable in macOS: \u00b6 Step 3.1 \u00b6 Depends on which shell you are using. If you are using Bash Shell, open the .bash_profile file using nano. nano ~/.bash_profile If you are using ZSH or Z Shell, open the .zprofile file using nano. nano ~/.zprofile GNU nano is a text editor for Unix-like computing systems or operating environments using a command line interface. Step 3.2 \u00b6 Add the following line at the top of the file you have opened. export PATH=\"/usr/local/opt/python/libexec/bin:$PATH\" Step 3.3 \u00b6 Save and exit the nano editor. Control + X Y Enter Step 3.4 \u00b6 Close all Terminal windows and quit Terminal entirely. Open Terminal again, check environment variable by using this command: echo $PATH It should response as follow: /usr/local/opt/python/libexec/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin Step 4: Check Python Versions and Pip Versions \u00b6 python --version it should return Python 3.x.x pip --version It should return soemthing like this pip 19.3.1 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) The Python version 3.x.x should match what pip is pointing at. References The Hitchhiker\u2019s Guide to Python: Installing Python 3 on Mac OS X Dirk Avery: The Right Way to Set Up Python on Your Mac Uninstall Python on Mac How to Modify the Shell Path in macOS Sierra and OSX using Terminal The right and wrong way to set Python 3 as default on a Mac","title":"on macOS"},{"location":"Day_0/install_python_mac/#how-to-install-vanilla-python-on-macos-properly","text":"","title":"How to Install Vanilla Python on macOS Properly?"},{"location":"Day_0/install_python_mac/#note-at-the-beginning","text":"Warning Do NOT remove Apple-supplied system Python 2.7.x (whatever version that is), as it may break the whole operating system. What is a Vanilla Install? Vanilla Install simply means not customized from their original form . What is Anaconda Python? Anaconda is a open-source Python distribution. It aims to provide everything you need (Python-wise) for data science \"out of the box\". It includes: The core Python language 100+ Python \"packages\" (libraries) Spyder IDE and Jupyter Notebook conda, Anaconda's own package manager, used for updating Anaconda and packages Reference: Matthias Braun If you think the following guide is overwhelming for you, Anaconda is a good choice for beginners, just head over to Anaconda distribution , choose Python 3.X for your operating system, download and install it, and you are good to go.","title":"Note at the beginning"},{"location":"Day_0/install_python_mac/#vanilla-install-python","text":"What to be installed: Homebrew : a package manager targeted at macOS. Similar to Apt for Linux. Pip : a package manager for the python world, installing python packages with pip will fetch packages from the Python Package Index . Python 3.7.X","title":"Vanilla Install Python"},{"location":"Day_0/install_python_mac/#step-0-remove-existing-3rd-party-python","text":"","title":"Step 0: Remove existing 3rd party Python"},{"location":"Day_0/install_python_mac/#step-01","text":"Open Finder, Navigate to /Applications , delete any folder named Python 2.X or Python 3.X .","title":"Step 0.1"},{"location":"Day_0/install_python_mac/#step-02","text":"Open Finder, go to your main Drive, usually Macintosh HD Use Finder, navigate to /Library/Frameworks/Python.framework/Versions/ Delete everything within /Versions folder. Alternatively, if you know what version of Python do you have, let say 3.6, you can use the following command in the Terminal. sudo rm -rf /Library/Frameworks/Python.framework/Versions/3.6","title":"Step 0.2"},{"location":"Day_0/install_python_mac/#step-03","text":"Remove all the symbolic links in /usr/local/bin that point to Python related files: sudo rm /usr/local/bin/python* sudo rm /usr/local/bin/pip*","title":"Step 0.3"},{"location":"Day_0/install_python_mac/#step-1-install-homebrew","text":"Open Terminal on your Mac and paste in the following command and hit Enter. /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Step 1: Install Homebrew"},{"location":"Day_0/install_python_mac/#step-2-install-python-using-homewbrew","text":"Type this in Terminal and hit Enter. brew install python Homebrew will install Pip as well.","title":"Step 2: Install Python using Homewbrew"},{"location":"Day_0/install_python_mac/#step-3-change-environment-variable-in-macos","text":"","title":"Step 3: Change Environment Variable in macOS:"},{"location":"Day_0/install_python_mac/#step-31","text":"Depends on which shell you are using. If you are using Bash Shell, open the .bash_profile file using nano. nano ~/.bash_profile If you are using ZSH or Z Shell, open the .zprofile file using nano. nano ~/.zprofile GNU nano is a text editor for Unix-like computing systems or operating environments using a command line interface.","title":"Step 3.1"},{"location":"Day_0/install_python_mac/#step-32","text":"Add the following line at the top of the file you have opened. export PATH=\"/usr/local/opt/python/libexec/bin:$PATH\"","title":"Step 3.2"},{"location":"Day_0/install_python_mac/#step-33","text":"Save and exit the nano editor. Control + X Y Enter","title":"Step 3.3"},{"location":"Day_0/install_python_mac/#step-34","text":"Close all Terminal windows and quit Terminal entirely. Open Terminal again, check environment variable by using this command: echo $PATH It should response as follow: /usr/local/opt/python/libexec/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin","title":"Step 3.4"},{"location":"Day_0/install_python_mac/#step-4-check-python-versions-and-pip-versions","text":"python --version it should return Python 3.x.x pip --version It should return soemthing like this pip 19.3.1 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) The Python version 3.x.x should match what pip is pointing at. References The Hitchhiker\u2019s Guide to Python: Installing Python 3 on Mac OS X Dirk Avery: The Right Way to Set Up Python on Your Mac Uninstall Python on Mac How to Modify the Shell Path in macOS Sierra and OSX using Terminal The right and wrong way to set Python 3 as default on a Mac","title":"Step 4: Check Python Versions and Pip Versions"},{"location":"Day_0/install_python_win/","text":"Install Python on Windows \u00b6 Use the following link to download and follow the on screen instructions. Link to Download python for windows Python Packages \u00b6 Open terminal for macOS or windows prompt for Windows and run the following commands: jupyter notebook \u00b6 pip install notebook requests \u00b6 pip install requests beautifulsoup \u00b6 pip install beautifulsoup4 Flask \u00b6 pip install flask pyrebase \u00b6 pip install pyrebase What's going on? We are now installing packages using pip which is the Python Package Manager. Since python is an open sourced programming language, many other developers have come up with amazing tools to enhance the use of python. These tools are what we call packages in which we use pip to manage those packages. To download a package using pip, we use a shell to interact with the computer. Opening terminal for macOS or command prompt for Windows: We run commands that look like this: pip install <name of package> TLDR: We download other people's code to use for our own so that we don't have to code out the same thing over and over again. Wait what is a shell? Computers you use now have graphical interface in which we press buttons to make the computer do stuff. However, what if we want to do more than what the buttons can do? That's why we have a shell, a texted based interface which we use to interact with the computer.","title":"on Windows"},{"location":"Day_0/install_python_win/#install-python-on-windows","text":"Use the following link to download and follow the on screen instructions. Link to Download python for windows","title":"Install Python on Windows"},{"location":"Day_0/install_python_win/#python-packages","text":"Open terminal for macOS or windows prompt for Windows and run the following commands:","title":"Python Packages"},{"location":"Day_0/install_python_win/#jupyter-notebook","text":"pip install notebook","title":"jupyter notebook"},{"location":"Day_0/install_python_win/#requests","text":"pip install requests","title":"requests"},{"location":"Day_0/install_python_win/#beautifulsoup","text":"pip install beautifulsoup4","title":"beautifulsoup"},{"location":"Day_0/install_python_win/#flask","text":"pip install flask","title":"Flask"},{"location":"Day_0/install_python_win/#pyrebase","text":"pip install pyrebase What's going on? We are now installing packages using pip which is the Python Package Manager. Since python is an open sourced programming language, many other developers have come up with amazing tools to enhance the use of python. These tools are what we call packages in which we use pip to manage those packages. To download a package using pip, we use a shell to interact with the computer. Opening terminal for macOS or command prompt for Windows: We run commands that look like this: pip install <name of package> TLDR: We download other people's code to use for our own so that we don't have to code out the same thing over and over again. Wait what is a shell? Computers you use now have graphical interface in which we press buttons to make the computer do stuff. However, what if we want to do more than what the buttons can do? That's why we have a shell, a texted based interface which we use to interact with the computer.","title":"pyrebase"},{"location":"Day_0/setup_guides/","text":"Environment Setup Guide \u00b6 Accounts \u00b6 Google : Make sure you have a Google Account. GitHub : Sign up for a free GitHub account if you haven't already. Software \u00b6 Postman : Download Postman . Python : Install Python on Windows Install Python on Linux Install Python on macOS Install on Intel Mac (2020 and before) Install on Mac with Apple Silicon (late-2020 M1 MacBooks)","title":"Setup Environment"},{"location":"Day_0/setup_guides/#environment-setup-guide","text":"","title":"Environment Setup Guide"},{"location":"Day_0/setup_guides/#accounts","text":"Google : Make sure you have a Google Account. GitHub : Sign up for a free GitHub account if you haven't already.","title":"Accounts"},{"location":"Day_0/setup_guides/#software","text":"Postman : Download Postman . Python : Install Python on Windows Install Python on Linux Install Python on macOS Install on Intel Mac (2020 and before) Install on Mac with Apple Silicon (late-2020 M1 MacBooks)","title":"Software"},{"location":"Day_1/python_basics/","text":"Day 1 \u00b6 What you will be learning today: \u00b6 What is Coding? Why Python? Variables and simple data types Intro to Functions Operators Strings Introduction to Lists Dictionaries Tuples Sets If statements loops: while and for What is Coding? \u00b6 Computer coding is the use of computer programming languages to give computers and machines as set of instructions on what actions to perform. It\u2019s how humans communicate with machines. Allows us to create computer software like programs, operating systems, and mobile apps. Without coding, computers would literally do nothing. They would be completely useless. That\u2019s because source code is the set of instructions that tells the computer what to do. Computers have no free will, after all, so without explicit instruction, they\u2019re just sophisticated hunks of metal. Think of anything you\u2019ve ever done with a computer: Play a video game. Send an email. Search for something on Google. Write a word document. Take a selfie on your smartphone (also a computer). Buy something on Amazon. Watch a movie on Netflix. All of those applications are software written in code. Why Python? \u00b6 Incredibly efficient language \"Clean code\" EASY to read, debug, build up and extend following is the the Python code that literally tells the computer to print 'I am awesome': 1 print ( \"I am awesome\" ) when in Java it is 1 2 3 4 5 public class HelloWorld { public static void main ( String [] args ) { System . out . println ( \"I am awesome\" ); } } And in C++ it is: 1 2 3 4 5 #include <iostream> int main () { std :: cout << \"I'am awesome. \\n \" ; } Variables \u00b6 Variables are often described as boxes you can store values in. This idea can be helpful the first few times you use a variable, but it\u2019s much better to think of variables as labels that you can assign to values. You can also say that a variable references a certain value. Data type is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data. A variable can be assigned to different types of values. Some basic data types in Python are: int : integer data type. Stores numbers without decimal points float : float data type. Stores decimal numbers with floating points str : sequences of character data. We will be going into further detail later. boolean : Objects of Boolean type may have one of two values, True or False Composite data types in Python : We will be exploring these data types in detail list : A list is a collection of items in a particular order dict : A dictionary in Python is a collection of key-value pairs. Each key is connected to a value, and you can use a key to access the value associated with that key tuple : A tuple looks just like a list except you use parentheses instead of square brackets. set : Sets are used to store multiple items in a single variable frozenset :frozenset is same as set except its elements cannot be changed. Variable Assignment \u00b6 Now let's see how to assign a variable the right way! Rules for Variable Names: Variable names can contain only letters, numbers, and underscores. They can start with a letter or an underscore, but not with a number. For instance, you can call a variable message_1 but not 1_message. The following special symbols also cannot be used in a variable name: :'\",<>/?|\\!@#%^&*~-+ Spaces are not allowed in variable names, but underscores can be used to separate words in variable names. For example, greeting_message works, but greeting message will cause errors. Avoid using Python keywords and function names as variable names. Keywords are words that Python has reserved for a particular programmatic purpose. Some examples of keywords are : print , input , type . Variable names should be short but descriptive. For example, name is better than n, student_name is better than s_n, and name_length is better than length_of_persons_name. Be careful when using the lowercase letter l and the uppercase letter O because they could be confused with the numbers 1 and 0. NOT ALLOWED: Will throw error 5five = 10 (Starting with a number) my var = 10 (Using spaces) my_var* = 10 (Using special symbols) Functions \u00b6 Why do we need them? \u00b6 Functions are a piece of code designed to do a certain task. Functions can be in-built or user-defined Consider the statement : print ( \"Hello World!\" ) print() is an in-built function of Python. It prints the specified message to the screen. But what if we want to print a statement at different parts of the program? Or let's say, you want to do the same task,( such as finding the average of given numbers, or printing out names ) again and again, at different times? Would you write that piece of code again ? Here's why we need functions. When you DEFINE a function, you can use the same code more than once, from any part of the program by CALLING it. Let's see how to do that! Defining a function \u00b6 def task_print (): #def is a keyword used for defining a function print ( \"Hello\" ) # use indentations after the first staement to create the body Calling a Function \u00b6 Defining the function means simply writing some code. Running it will not give you anything since you are not using it . So you need to call the function to execute its body: task_print () # simply the function name with the brackets. Now try running it! What are the brackets for? A function often receives certain arguments which are used in the function body. For example, if you want to print a name on the screen but the name is to be given by the user, you can pass the name as an ARGUMENT to the function def task_2 ( name ): # function definition print ( name ) task_2 ( \"Zac\" ) # function Call task_2 ( \"I can change the name !\" ) task_2 ( \"Emily\" ) in the above example, \"Zac\" is an argument which is used in the CALL statement. This argument gets passed to the function definition. Thus name is an argument that now has the value Zac. Return Statement \u00b6 We just saw how functions can receive arguments and work upon them. What if we want to extract some value from the function, i.e. , we want the function to RETURN something? return statement is used in the function body to return a value ( or values) back to the function call . def add_numbers ( num1 , num2 ) : total = num1 + num2 return ( total ) num1 = 2 num2 = 4 addition_product = add_numbers ( num1 , num2 ) #the value returned by the function is now assigned to the variable \"addition product\" print ( addition_product ) Do NOTE that functions don't necessarily have to return a value: def add_numbers ( num1 , num2 ) : total = num1 + num2 print ( total ) num1 = 2 num2 = 4 addition_product = add_numbers ( num1 , num2 ) #the value returned by the function is now assigned to the variable \"addition product\" print ( addition_product ) In the above function, there is no return statement. Thus the None value of addition_product Other in-built functions \u00b6 You have learnt to define and call your own function. Let's see some more in-built functions of Python What if you want to know what data type is the variable? type() : this in-built function is used to determine the data type of the variable print ( type ( message )) type ( 2 ) Suppose you don't know what value should be assigned to your variable and want to ask the user for the value. you can do this using input() input() method reads a line from input, converts into a string and returns it. message = input () print ( \"You entered: \" , message ) #Suppose you want to print a message to the user for asking the value second_message = input ( \"Please enter a number\" ) print ( second_message ) Converting data types \u00b6 Data types can be converted from one form to another using in-built functions like int(), str(), float(). However, do note that not every conversion is possible! Can you convert an int type to a string type? #using the in-built function str() num = 1 num = str ( num ) print ( num ) print ( type ( num )) How about converting str to int? letter = 'A' letter = int ( letter ) letter1 = '3' letter1 = int ( letter1 ) print ( type ( letter1 )) Operators \u00b6 Arithmetic Operators: x = 15 y = 4 # Output: x + y = 19 print ( 'x + y =' , x + y ) # Output: x - y = 11 print ( 'x - y =' , x - y ) # Output: x * y = 60 print ( 'x * y =' , x * y ) # Output: x / y = 3.75 print ( 'x / y =' , x / y ) # Output: x // y = 3 print ( 'x // y =' , x // y ) # Output: x ** y = 50625 print ( 'x ** y =' , x ** y ) Comparison Operators: x = 10 y = 12 # Output: x > y is False print ( 'x > y is' , x > y ) # Output: x < y is True print ( 'x < y is' , x < y ) # Output: x == y is False print ( 'x == y is' , x == y ) # Output: x != y is True print ( 'x != y is' , x != y ) # Output: x >= y is False print ( 'x >= y is' , x >= y ) # Output: x <= y is True print ( 'x <= y is' , x <= y ) Logical Operators : x = True y = False print ( 'x and y is' , x and y ) print ( 'x or y is' , x or y ) print ( 'not x is' , not x ) Shorthand Assignment operators: In normal mathematics expressions: var = 0 var = var +1 would mean 0 = 1 But in python, the same expression has a different meaning . It means that the value of var is incremented by one and then assigned back to var. Thus the expression would store the value of 1 in var. Strings \u00b6 A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings : I told my friend, \"Python is my favorite language!\"' \"The language 'Python' is named after Monty Python, not the snake.\" \"One of Python's strengths is its diverse and supportive community.\" String indexing and slicing \u00b6 Strings are a sequence, which means Python can use indexes to call parts of the sequence. Indexing - Retrieving one letter from the string Slicing - Retrieving multiple letters (Sub-string) from the string In Python, we use brackets [] after an object to call its index. We should also note that indexing starts at 0 for Python. Let's create a new object called s and then walk through a few examples of indexing. Syntax for []: Starting Index (Inclusive), End Index (Exclusive), Step Size # Outputs the first letter. Remember: In Python, index starts from '0' print ( my_var [ 0 ]) # Outputs the first to fourth letter. Indexing works by INCLUDING left bound but EXCLUDING right bound print ( my_var [ 0 : 4 ]) # Outputs the first and third letter. print ( my_var [ 0 : 4 : 2 ]) # Reversing a string print ( my_var [:: - 1 ]) Practice 1 : Print 'I Love Coding' from the string below: s = \"3DC'20 - I Love Coding!\" Strings are immutable \u00b6 This means that once a string is created, the elements within it can not be changed or replaced. For example: s = \"I love coding\" #try changing the first letter to x s [ 0 ] = \"x\" #What do you get? String Concatenation \u00b6 Dictionary definition of concatenation: \"the action of linking things together in a series, or the condition of being linked in such a way\" Layman term: Joining 2 or more strings together s #we can reassign the new string back to s s = s + \" concatenate me\" print ( s ) How does the multiplication operator behave with strings ? length = \"z\" print ( length * 3 ) Practice 2: Suppose you had a person's name in a variable: myName = \"Kenny Carney\" However, you want the surname Carney first and then the first name of Kenny. Use slicing to print out Carney Kenny. Remember: you can use the plus symbol and spaces to concatenate: print(surname + \" \" + firstName) Advanced Practice : Palindromes Given a string, write a code to check if it is palindrome or not. A string is said to be palindrome if the reverse of the string is the same as string. For example, \u201cradar\u201d is a palindrome, but \u201cradix\u201d is not a palindrome. Introduction to Lists \u00b6 A list is a collection of items in a particular order. In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas bicycles = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicycles ) Accessing Elements \u00b6 Lists are ordered collections, so you can access any element in a list by telling Python the position, or index, of the item desired Python considers the first item in a list to be at position 0, not position 1. print ( bicycles [ 0 ]) To access elements from the back of a list, use a negative index. An index of -1 would access the last element, -2 would access the second last element and so on. a = [ 1 , 1.0 , 'python' , True ] print ( a [ - 1 ]) print ( a [ - 2 ] ) Lists are mutable \u00b6 You do this by referencing the element of the list and assigning a new object to it. a = [ 1 , 1.0 , 'python' , True ] a [ 2 ] = 'SUTD' print ( a ) len() function \u00b6 The length of a list is the number of elements that it contains. Use the len function to check its length. a = [ 1 , 1.0 , 'python' , True ] print ( len ( a )) Creating a list \u00b6 An empty list has a length of zero. You can either use the list() function or [] to create an empty list. a = list () b = [] print ( a , b ) print ( len ( a ), len ( b )) Using range() range() function is used to produce numbers using a start, stop, step range(2,10,1) will produce numbers starting from 2, incrementing by 2, till it becomes 10. Note that it DOES NOT include 10 As the range() function is not a list, you need to pass it to the list() function to create a list. ls = list ( range ( 10 )) print ( ls ) Methods of Lists \u00b6 The term method refers to a function that is attached to a data type. A list object has functions attached to it. These are called methods . You access methods using the dot operator. Note: All of the below functions are applied directly to the original list append() : add elements to the back of a list. a = [ 1 , 1.0 , 'python' , True ] a . append ( 'five' ) print ( a ) pop() : Removes the last element from the list. # Remove the last element from the list ls = [ 1 , 2 , 3 , 4 , 5 , \"This will be removed from the list\" ] print ( ls ) ls . pop () # Note that .pop() is applied directly to the list I.e. There is no need to do ls = ls.pop() print ( ls ) reverse() : Reverses the order of all elements in the list. # Reverses the order of the list ls . reverse () print ( ls ) List Slicing \u00b6 In the following example, a list assigned to b is created by extracting element with index 2 , up to but not including element index 4 . The default increment is 1. a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] b = a [ 2 : 4 ] In the following example, a list assigned to b is created by extracting element with index 1 , up to and including the last element , in increments of 2 . a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] b = a [ 1 :: 2 ] The in Keyword a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] print ( 'cat' in a ) print ( 'donkey' in a ) The \"+\", \" * \" and \"==\" operators with lists Recall that the \"+\" operator behaves differently with two numbers compared to two strings. The \"+\"and \" * \" operators behave differently with lists, compared to the numeric datatypes. The \"+\" operator performs concatenation when both its operands are lists. a = [ 1 , 2 , 3 ] b = [ 7 , 8 , 9 ] c = a + b print ( c ) The \" * \" operator works with a list and an integer. a = [ 1 , 2 , 3 ] c = a * 3 print ( c ) The \" == \" operator checks the equality of two lists. This includes the length and all the elements in the list a = [ 1 , 2 , 3 ] b = [ 3 , 1 , 2 ] c = [ 1 , 2 , 3 ] print ( a == b ) print ( a == c ) Copying a list \u00b6 By writing b=a in the example below, we are not creating a copy of a list. Recall that the = operator is an assignment operator. What the code does below is aliasing . The same set of data that is referenced by variable a is also referenced by b . In other words, both variables a and b refer to the same set of information. a = [ 1 , 2 , 3 ] b = a Hence, what would we see on the screen if we had the following code? a = [ 1 , 2 , 3 ] b = a b [ 2 ] = 5 print ( a ) print ( b ) A list slice creates a copy of a list. List slicing can be used to create a copy of a list a = [ 1 , 2 , 3 ] b = a [:] print ( a is b ) print ( a == b ) The is operator \u00b6 The is operator checks if aliasing is happening. a = [ 1 , 2 , 3 ] b = a print ( a is b ) Practice 3 #1. What will the below code produce? x = [ 0 , 1 , 2 , 3 , 4 , 5 ] x == x [: 3 ] + x [ 3 :] Dictionaries \u00b6 We've been learning about sequences in Python but now we're going to switch gears and learn about mappings in Python. If you're familiar with other languages you can think of these Dictionaries as hash tables. So what are mappings? Mappings are a collection of objects that are stored by a key, unlike a sequence that stores objects by their relative position. This is an important distinction, since mappings won't retain order since they have objects defined by a key. A Python dictionary consists of a key and then an associated value. That value can be almost any Python object. Constructing a dictionary \u00b6 # Make a dictionary with {} and : to signify a key and a value my_dict = { 'key1' : 'value1' , 'key2' : 'value2' } Accessing a value \u00b6 # Access a value by inputting its key my_dict [ \"key1\" ] # Dictionaries, like lists, can hold different data types my_dict = { 'key1' : 123 , 'key2' :[ 12 , 23 , 33 ], 'key3' :[ 'item0' , 'item1' , 'item2' ]} Dictionaries are mutable \u00b6 # The values can be reassigned my_dict [ \"key1\" ] = 456 # New values can be assigned my_dict [ \"key4\" ] = \"New Value\" print ( my_dict ) Nested Dictionaries \u00b6 # Accessing nested dictionaries d = { 'k1' : [ 1 , 2 ,{ 'k2' :[[ \"Hello!\" ]]}]} d [ 'k1' ][ 2 ][ 'k2' ][ 0 ][ 0 ] Practice 4: Retrieve 'Coding is fun unless you're doing it wrong' d = { 'k1' :[ 1 , 2 ,{ 'k2' :[ 'pls do not do this' ,{ 'have fun' :[ 1 , 2 ,[ 'Coding is fun unless you \\' re doing it wrong' , 1 , 2 ]]}]}]} Tuples \u00b6 In Python tuples are very similar to lists, however, unlike lists they are immutable meaning they can not be changed. You would use tuples to present things that shouldn't be changed, such as days of the week, or dates on a calendar. You'll have an intuition of how to use tuples based on what you've learned about lists. Constructing Tuples \u00b6 The construction of a tuples use () with elements separated by commas. For example: tup = ( \"This will not change\" , True ) print ( tup ) Immutability \u00b6 It can't be stressed enough that tuples are immutable. No variable reassignment! To drive that point home: tup [ 0 ] = \"This will not work print ( tup [ 0 ]) Sets \u00b6 Sets are an unordered collection of unique elements . We can construct them by using the set() function. What's the purpose? One main reason is to identify unique elements from a list x = set() x.add(1) x Note the curly brackets. This does not indicate a dictionary! Although you can draw analogies as a set being a dictionary with only keys. We know that a set has only unique entries. So what happens when we try to add something that is already in a set? x.add(1) x # Notice how there is still only 1 element? Conditionals : if, else and elif \u00b6 Programming often involves examining a set of conditions and deciding which action to take based on those conditions. Python\u2019s if statement allows you to examine the current state of a program and respond appropriately to that state. cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) car = 'bmw' car == 'bmw' # What is the difference between the two operators? Checking for inequality : requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) ``` ### If-else block An if - else block is similar to a simple if statement , but the else statement allows you to define an action or set of actions that are executed when the conditional test fails . ``` python age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registered to vote yet?\" ) else : print ( \"Sorry, you are too young to vote.\" ) print ( \"Please register to vote as soon as you turn 18!\" ) NOTE The else block is a catchall statement. It matches any condition that wasn\u2019t matched by a specific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final condition you are testing for, consider using a final elif block and omit the else block. As a result, you\u2019ll gain extra confidence that your code will run only under the correct conditions. for Loop \u00b6 A for loop acts as an iterator in Python; it goes through items that are in a sequence or any other iterable item. Objects that we've learned about that we can iterate over include strings, lists, tuples, and even built-in iterables for dictionaries, such as keys or values. Here's the general format for a for loop in Python: for item in object : statements to do stuff Iterating through a list \u00b6 list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # Note: The list can also be created via range() list2 = list ( range ( 1 , 11 )) for el in list1 : print ( i ) # This is the same as the following: for el in range ( 1 , 11 ): print ( i ) while loop \u00b6 A bit similar to for loop, but it keeps running until the condition is false The main difference between for loop and while loop is for loop is used in situations where you know the number of iterations to go through while loop is used in situations where you do not know the number of iterations to go through but you know what is the condition that it should stop # Only when the condition behind the while statement is True, then only it will enter the loop # So do remember to update the condition for you to exit the while loop. # Unless you want it to run forever index = 1 while index < 5 : print ( 'This statement is printed {} times' . format ( index )) index += 1 print ( index ) Practice 6: one of the important application of while loop is to validate input from user prompt the user to input their gender and if its not M or F you will notify them that its wrong input and ask them to input again HANDS-ON \u00b6 Now that we have learnt the fundamentals of python programming, let's built something of our own that's useful! NRIC validator \u00b6 Do you know how to verify an NRIC number? Here are some guidelines: The steps involved in the computation are as follows: 1) Multiply each digit in the NRIC number by its weight i.e. 2 7 6 5 4 3 2 in order. 2) Add together the above products. 3) If the first letter i.e. UIN of the NRIC starts with T or G, add 4 to the total. 4) Find the remainder of (sum calculated above) mod 11. (total %11) 5) Compare the digit you get from last step to the following list: If the NRIC starts with F or G: 0=X, 1=W, 2=U, 3=T, 4=R, 5=Q, 6=P, 7=N, 8=M, 9=L, 10=K. If the NRIC starts with S or T: 0=J, 1=Z, 2=I, 3=H, 4=G, 5=F, 6=E, 7=D, 8=C, 9=B, 10=A After matching to the list, the letter that you get should be the last letter of the nric code ! And thus the nric number is verified! How to go about it? Do you need functions? Which data type(complex) would you use for assigning the alphabets to digits in step 5 ? Optional Practice Questions! \u00b6 Write a function to print the following pattern using for/ while loops : * ** *** **** ***** Factorial of a number n is represented by n! and is equal to 1 * 2 * 3 * .... * (n-1) * n 5! = 5 * 4 * 3 * 2 * 1 = 120 Write a program to calculate the factorial of a number given by the user","title":"Python Basics"},{"location":"Day_1/python_basics/#day-1","text":"","title":"Day 1"},{"location":"Day_1/python_basics/#what-you-will-be-learning-today","text":"What is Coding? Why Python? Variables and simple data types Intro to Functions Operators Strings Introduction to Lists Dictionaries Tuples Sets If statements loops: while and for","title":"What you will be learning today:"},{"location":"Day_1/python_basics/#what-is-coding","text":"Computer coding is the use of computer programming languages to give computers and machines as set of instructions on what actions to perform. It\u2019s how humans communicate with machines. Allows us to create computer software like programs, operating systems, and mobile apps. Without coding, computers would literally do nothing. They would be completely useless. That\u2019s because source code is the set of instructions that tells the computer what to do. Computers have no free will, after all, so without explicit instruction, they\u2019re just sophisticated hunks of metal. Think of anything you\u2019ve ever done with a computer: Play a video game. Send an email. Search for something on Google. Write a word document. Take a selfie on your smartphone (also a computer). Buy something on Amazon. Watch a movie on Netflix. All of those applications are software written in code.","title":"What is Coding?"},{"location":"Day_1/python_basics/#why-python","text":"Incredibly efficient language \"Clean code\" EASY to read, debug, build up and extend following is the the Python code that literally tells the computer to print 'I am awesome': 1 print ( \"I am awesome\" ) when in Java it is 1 2 3 4 5 public class HelloWorld { public static void main ( String [] args ) { System . out . println ( \"I am awesome\" ); } } And in C++ it is: 1 2 3 4 5 #include <iostream> int main () { std :: cout << \"I'am awesome. \\n \" ; }","title":"Why Python?"},{"location":"Day_1/python_basics/#variables","text":"Variables are often described as boxes you can store values in. This idea can be helpful the first few times you use a variable, but it\u2019s much better to think of variables as labels that you can assign to values. You can also say that a variable references a certain value. Data type is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data. A variable can be assigned to different types of values. Some basic data types in Python are: int : integer data type. Stores numbers without decimal points float : float data type. Stores decimal numbers with floating points str : sequences of character data. We will be going into further detail later. boolean : Objects of Boolean type may have one of two values, True or False Composite data types in Python : We will be exploring these data types in detail list : A list is a collection of items in a particular order dict : A dictionary in Python is a collection of key-value pairs. Each key is connected to a value, and you can use a key to access the value associated with that key tuple : A tuple looks just like a list except you use parentheses instead of square brackets. set : Sets are used to store multiple items in a single variable frozenset :frozenset is same as set except its elements cannot be changed.","title":"Variables"},{"location":"Day_1/python_basics/#variable-assignment","text":"Now let's see how to assign a variable the right way! Rules for Variable Names: Variable names can contain only letters, numbers, and underscores. They can start with a letter or an underscore, but not with a number. For instance, you can call a variable message_1 but not 1_message. The following special symbols also cannot be used in a variable name: :'\",<>/?|\\!@#%^&*~-+ Spaces are not allowed in variable names, but underscores can be used to separate words in variable names. For example, greeting_message works, but greeting message will cause errors. Avoid using Python keywords and function names as variable names. Keywords are words that Python has reserved for a particular programmatic purpose. Some examples of keywords are : print , input , type . Variable names should be short but descriptive. For example, name is better than n, student_name is better than s_n, and name_length is better than length_of_persons_name. Be careful when using the lowercase letter l and the uppercase letter O because they could be confused with the numbers 1 and 0. NOT ALLOWED: Will throw error 5five = 10 (Starting with a number) my var = 10 (Using spaces) my_var* = 10 (Using special symbols)","title":"Variable Assignment"},{"location":"Day_1/python_basics/#functions","text":"","title":"Functions"},{"location":"Day_1/python_basics/#why-do-we-need-them","text":"Functions are a piece of code designed to do a certain task. Functions can be in-built or user-defined Consider the statement : print ( \"Hello World!\" ) print() is an in-built function of Python. It prints the specified message to the screen. But what if we want to print a statement at different parts of the program? Or let's say, you want to do the same task,( such as finding the average of given numbers, or printing out names ) again and again, at different times? Would you write that piece of code again ? Here's why we need functions. When you DEFINE a function, you can use the same code more than once, from any part of the program by CALLING it. Let's see how to do that!","title":"Why do we need them?"},{"location":"Day_1/python_basics/#defining-a-function","text":"def task_print (): #def is a keyword used for defining a function print ( \"Hello\" ) # use indentations after the first staement to create the body","title":"Defining a function"},{"location":"Day_1/python_basics/#calling-a-function","text":"Defining the function means simply writing some code. Running it will not give you anything since you are not using it . So you need to call the function to execute its body: task_print () # simply the function name with the brackets. Now try running it! What are the brackets for? A function often receives certain arguments which are used in the function body. For example, if you want to print a name on the screen but the name is to be given by the user, you can pass the name as an ARGUMENT to the function def task_2 ( name ): # function definition print ( name ) task_2 ( \"Zac\" ) # function Call task_2 ( \"I can change the name !\" ) task_2 ( \"Emily\" ) in the above example, \"Zac\" is an argument which is used in the CALL statement. This argument gets passed to the function definition. Thus name is an argument that now has the value Zac.","title":"Calling a Function"},{"location":"Day_1/python_basics/#return-statement","text":"We just saw how functions can receive arguments and work upon them. What if we want to extract some value from the function, i.e. , we want the function to RETURN something? return statement is used in the function body to return a value ( or values) back to the function call . def add_numbers ( num1 , num2 ) : total = num1 + num2 return ( total ) num1 = 2 num2 = 4 addition_product = add_numbers ( num1 , num2 ) #the value returned by the function is now assigned to the variable \"addition product\" print ( addition_product ) Do NOTE that functions don't necessarily have to return a value: def add_numbers ( num1 , num2 ) : total = num1 + num2 print ( total ) num1 = 2 num2 = 4 addition_product = add_numbers ( num1 , num2 ) #the value returned by the function is now assigned to the variable \"addition product\" print ( addition_product ) In the above function, there is no return statement. Thus the None value of addition_product","title":"Return Statement"},{"location":"Day_1/python_basics/#other-in-built-functions","text":"You have learnt to define and call your own function. Let's see some more in-built functions of Python What if you want to know what data type is the variable? type() : this in-built function is used to determine the data type of the variable print ( type ( message )) type ( 2 ) Suppose you don't know what value should be assigned to your variable and want to ask the user for the value. you can do this using input() input() method reads a line from input, converts into a string and returns it. message = input () print ( \"You entered: \" , message ) #Suppose you want to print a message to the user for asking the value second_message = input ( \"Please enter a number\" ) print ( second_message )","title":"Other in-built functions"},{"location":"Day_1/python_basics/#converting-data-types","text":"Data types can be converted from one form to another using in-built functions like int(), str(), float(). However, do note that not every conversion is possible! Can you convert an int type to a string type? #using the in-built function str() num = 1 num = str ( num ) print ( num ) print ( type ( num )) How about converting str to int? letter = 'A' letter = int ( letter ) letter1 = '3' letter1 = int ( letter1 ) print ( type ( letter1 ))","title":"Converting data types"},{"location":"Day_1/python_basics/#operators","text":"Arithmetic Operators: x = 15 y = 4 # Output: x + y = 19 print ( 'x + y =' , x + y ) # Output: x - y = 11 print ( 'x - y =' , x - y ) # Output: x * y = 60 print ( 'x * y =' , x * y ) # Output: x / y = 3.75 print ( 'x / y =' , x / y ) # Output: x // y = 3 print ( 'x // y =' , x // y ) # Output: x ** y = 50625 print ( 'x ** y =' , x ** y ) Comparison Operators: x = 10 y = 12 # Output: x > y is False print ( 'x > y is' , x > y ) # Output: x < y is True print ( 'x < y is' , x < y ) # Output: x == y is False print ( 'x == y is' , x == y ) # Output: x != y is True print ( 'x != y is' , x != y ) # Output: x >= y is False print ( 'x >= y is' , x >= y ) # Output: x <= y is True print ( 'x <= y is' , x <= y ) Logical Operators : x = True y = False print ( 'x and y is' , x and y ) print ( 'x or y is' , x or y ) print ( 'not x is' , not x ) Shorthand Assignment operators: In normal mathematics expressions: var = 0 var = var +1 would mean 0 = 1 But in python, the same expression has a different meaning . It means that the value of var is incremented by one and then assigned back to var. Thus the expression would store the value of 1 in var.","title":"Operators"},{"location":"Day_1/python_basics/#strings","text":"A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings : I told my friend, \"Python is my favorite language!\"' \"The language 'Python' is named after Monty Python, not the snake.\" \"One of Python's strengths is its diverse and supportive community.\"","title":"Strings"},{"location":"Day_1/python_basics/#string-indexing-and-slicing","text":"Strings are a sequence, which means Python can use indexes to call parts of the sequence. Indexing - Retrieving one letter from the string Slicing - Retrieving multiple letters (Sub-string) from the string In Python, we use brackets [] after an object to call its index. We should also note that indexing starts at 0 for Python. Let's create a new object called s and then walk through a few examples of indexing. Syntax for []: Starting Index (Inclusive), End Index (Exclusive), Step Size # Outputs the first letter. Remember: In Python, index starts from '0' print ( my_var [ 0 ]) # Outputs the first to fourth letter. Indexing works by INCLUDING left bound but EXCLUDING right bound print ( my_var [ 0 : 4 ]) # Outputs the first and third letter. print ( my_var [ 0 : 4 : 2 ]) # Reversing a string print ( my_var [:: - 1 ]) Practice 1 : Print 'I Love Coding' from the string below: s = \"3DC'20 - I Love Coding!\"","title":"String indexing and slicing"},{"location":"Day_1/python_basics/#strings-are-immutable","text":"This means that once a string is created, the elements within it can not be changed or replaced. For example: s = \"I love coding\" #try changing the first letter to x s [ 0 ] = \"x\" #What do you get?","title":"Strings are immutable"},{"location":"Day_1/python_basics/#string-concatenation","text":"Dictionary definition of concatenation: \"the action of linking things together in a series, or the condition of being linked in such a way\" Layman term: Joining 2 or more strings together s #we can reassign the new string back to s s = s + \" concatenate me\" print ( s ) How does the multiplication operator behave with strings ? length = \"z\" print ( length * 3 ) Practice 2: Suppose you had a person's name in a variable: myName = \"Kenny Carney\" However, you want the surname Carney first and then the first name of Kenny. Use slicing to print out Carney Kenny. Remember: you can use the plus symbol and spaces to concatenate: print(surname + \" \" + firstName) Advanced Practice : Palindromes Given a string, write a code to check if it is palindrome or not. A string is said to be palindrome if the reverse of the string is the same as string. For example, \u201cradar\u201d is a palindrome, but \u201cradix\u201d is not a palindrome.","title":"String Concatenation"},{"location":"Day_1/python_basics/#introduction-to-lists","text":"A list is a collection of items in a particular order. In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas bicycles = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicycles )","title":"Introduction to Lists"},{"location":"Day_1/python_basics/#accessing-elements","text":"Lists are ordered collections, so you can access any element in a list by telling Python the position, or index, of the item desired Python considers the first item in a list to be at position 0, not position 1. print ( bicycles [ 0 ]) To access elements from the back of a list, use a negative index. An index of -1 would access the last element, -2 would access the second last element and so on. a = [ 1 , 1.0 , 'python' , True ] print ( a [ - 1 ]) print ( a [ - 2 ] )","title":"Accessing Elements"},{"location":"Day_1/python_basics/#lists-are-mutable","text":"You do this by referencing the element of the list and assigning a new object to it. a = [ 1 , 1.0 , 'python' , True ] a [ 2 ] = 'SUTD' print ( a )","title":"Lists are mutable"},{"location":"Day_1/python_basics/#len-function","text":"The length of a list is the number of elements that it contains. Use the len function to check its length. a = [ 1 , 1.0 , 'python' , True ] print ( len ( a ))","title":"len() function"},{"location":"Day_1/python_basics/#creating-a-list","text":"An empty list has a length of zero. You can either use the list() function or [] to create an empty list. a = list () b = [] print ( a , b ) print ( len ( a ), len ( b )) Using range() range() function is used to produce numbers using a start, stop, step range(2,10,1) will produce numbers starting from 2, incrementing by 2, till it becomes 10. Note that it DOES NOT include 10 As the range() function is not a list, you need to pass it to the list() function to create a list. ls = list ( range ( 10 )) print ( ls )","title":"Creating a list"},{"location":"Day_1/python_basics/#methods-of-lists","text":"The term method refers to a function that is attached to a data type. A list object has functions attached to it. These are called methods . You access methods using the dot operator. Note: All of the below functions are applied directly to the original list append() : add elements to the back of a list. a = [ 1 , 1.0 , 'python' , True ] a . append ( 'five' ) print ( a ) pop() : Removes the last element from the list. # Remove the last element from the list ls = [ 1 , 2 , 3 , 4 , 5 , \"This will be removed from the list\" ] print ( ls ) ls . pop () # Note that .pop() is applied directly to the list I.e. There is no need to do ls = ls.pop() print ( ls ) reverse() : Reverses the order of all elements in the list. # Reverses the order of the list ls . reverse () print ( ls )","title":"Methods of Lists"},{"location":"Day_1/python_basics/#list-slicing","text":"In the following example, a list assigned to b is created by extracting element with index 2 , up to but not including element index 4 . The default increment is 1. a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] b = a [ 2 : 4 ] In the following example, a list assigned to b is created by extracting element with index 1 , up to and including the last element , in increments of 2 . a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] b = a [ 1 :: 2 ] The in Keyword a = [ 'horse' , 'cat' , 'dog' , 'chicken' , 'rat' , 'duck' , 'pigeon' ] print ( 'cat' in a ) print ( 'donkey' in a ) The \"+\", \" * \" and \"==\" operators with lists Recall that the \"+\" operator behaves differently with two numbers compared to two strings. The \"+\"and \" * \" operators behave differently with lists, compared to the numeric datatypes. The \"+\" operator performs concatenation when both its operands are lists. a = [ 1 , 2 , 3 ] b = [ 7 , 8 , 9 ] c = a + b print ( c ) The \" * \" operator works with a list and an integer. a = [ 1 , 2 , 3 ] c = a * 3 print ( c ) The \" == \" operator checks the equality of two lists. This includes the length and all the elements in the list a = [ 1 , 2 , 3 ] b = [ 3 , 1 , 2 ] c = [ 1 , 2 , 3 ] print ( a == b ) print ( a == c )","title":"List Slicing"},{"location":"Day_1/python_basics/#copying-a-list","text":"By writing b=a in the example below, we are not creating a copy of a list. Recall that the = operator is an assignment operator. What the code does below is aliasing . The same set of data that is referenced by variable a is also referenced by b . In other words, both variables a and b refer to the same set of information. a = [ 1 , 2 , 3 ] b = a Hence, what would we see on the screen if we had the following code? a = [ 1 , 2 , 3 ] b = a b [ 2 ] = 5 print ( a ) print ( b ) A list slice creates a copy of a list. List slicing can be used to create a copy of a list a = [ 1 , 2 , 3 ] b = a [:] print ( a is b ) print ( a == b )","title":"Copying a list"},{"location":"Day_1/python_basics/#the-is-operator","text":"The is operator checks if aliasing is happening. a = [ 1 , 2 , 3 ] b = a print ( a is b ) Practice 3 #1. What will the below code produce? x = [ 0 , 1 , 2 , 3 , 4 , 5 ] x == x [: 3 ] + x [ 3 :]","title":"The is operator"},{"location":"Day_1/python_basics/#dictionaries","text":"We've been learning about sequences in Python but now we're going to switch gears and learn about mappings in Python. If you're familiar with other languages you can think of these Dictionaries as hash tables. So what are mappings? Mappings are a collection of objects that are stored by a key, unlike a sequence that stores objects by their relative position. This is an important distinction, since mappings won't retain order since they have objects defined by a key. A Python dictionary consists of a key and then an associated value. That value can be almost any Python object.","title":"Dictionaries"},{"location":"Day_1/python_basics/#constructing-a-dictionary","text":"# Make a dictionary with {} and : to signify a key and a value my_dict = { 'key1' : 'value1' , 'key2' : 'value2' }","title":"Constructing a dictionary"},{"location":"Day_1/python_basics/#accessing-a-value","text":"# Access a value by inputting its key my_dict [ \"key1\" ] # Dictionaries, like lists, can hold different data types my_dict = { 'key1' : 123 , 'key2' :[ 12 , 23 , 33 ], 'key3' :[ 'item0' , 'item1' , 'item2' ]}","title":"Accessing a value"},{"location":"Day_1/python_basics/#dictionaries-are-mutable","text":"# The values can be reassigned my_dict [ \"key1\" ] = 456 # New values can be assigned my_dict [ \"key4\" ] = \"New Value\" print ( my_dict )","title":"Dictionaries are mutable"},{"location":"Day_1/python_basics/#nested-dictionaries","text":"# Accessing nested dictionaries d = { 'k1' : [ 1 , 2 ,{ 'k2' :[[ \"Hello!\" ]]}]} d [ 'k1' ][ 2 ][ 'k2' ][ 0 ][ 0 ] Practice 4: Retrieve 'Coding is fun unless you're doing it wrong' d = { 'k1' :[ 1 , 2 ,{ 'k2' :[ 'pls do not do this' ,{ 'have fun' :[ 1 , 2 ,[ 'Coding is fun unless you \\' re doing it wrong' , 1 , 2 ]]}]}]}","title":"Nested Dictionaries"},{"location":"Day_1/python_basics/#tuples","text":"In Python tuples are very similar to lists, however, unlike lists they are immutable meaning they can not be changed. You would use tuples to present things that shouldn't be changed, such as days of the week, or dates on a calendar. You'll have an intuition of how to use tuples based on what you've learned about lists.","title":"Tuples"},{"location":"Day_1/python_basics/#constructing-tuples","text":"The construction of a tuples use () with elements separated by commas. For example: tup = ( \"This will not change\" , True ) print ( tup )","title":"Constructing Tuples"},{"location":"Day_1/python_basics/#immutability","text":"It can't be stressed enough that tuples are immutable. No variable reassignment! To drive that point home: tup [ 0 ] = \"This will not work print ( tup [ 0 ])","title":"Immutability"},{"location":"Day_1/python_basics/#sets","text":"Sets are an unordered collection of unique elements . We can construct them by using the set() function. What's the purpose? One main reason is to identify unique elements from a list x = set() x.add(1) x Note the curly brackets. This does not indicate a dictionary! Although you can draw analogies as a set being a dictionary with only keys. We know that a set has only unique entries. So what happens when we try to add something that is already in a set? x.add(1) x # Notice how there is still only 1 element?","title":"Sets"},{"location":"Day_1/python_basics/#conditionals-if-else-and-elif","text":"Programming often involves examining a set of conditions and deciding which action to take based on those conditions. Python\u2019s if statement allows you to examine the current state of a program and respond appropriately to that state. cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) car = 'bmw' car == 'bmw' # What is the difference between the two operators? Checking for inequality : requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) ``` ### If-else block An if - else block is similar to a simple if statement , but the else statement allows you to define an action or set of actions that are executed when the conditional test fails . ``` python age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registered to vote yet?\" ) else : print ( \"Sorry, you are too young to vote.\" ) print ( \"Please register to vote as soon as you turn 18!\" ) NOTE The else block is a catchall statement. It matches any condition that wasn\u2019t matched by a specific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final condition you are testing for, consider using a final elif block and omit the else block. As a result, you\u2019ll gain extra confidence that your code will run only under the correct conditions.","title":"Conditionals : if, else and elif"},{"location":"Day_1/python_basics/#for-loop","text":"A for loop acts as an iterator in Python; it goes through items that are in a sequence or any other iterable item. Objects that we've learned about that we can iterate over include strings, lists, tuples, and even built-in iterables for dictionaries, such as keys or values. Here's the general format for a for loop in Python: for item in object : statements to do stuff","title":"for Loop"},{"location":"Day_1/python_basics/#iterating-through-a-list","text":"list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # Note: The list can also be created via range() list2 = list ( range ( 1 , 11 )) for el in list1 : print ( i ) # This is the same as the following: for el in range ( 1 , 11 ): print ( i )","title":"Iterating through a list"},{"location":"Day_1/python_basics/#while-loop","text":"A bit similar to for loop, but it keeps running until the condition is false The main difference between for loop and while loop is for loop is used in situations where you know the number of iterations to go through while loop is used in situations where you do not know the number of iterations to go through but you know what is the condition that it should stop # Only when the condition behind the while statement is True, then only it will enter the loop # So do remember to update the condition for you to exit the while loop. # Unless you want it to run forever index = 1 while index < 5 : print ( 'This statement is printed {} times' . format ( index )) index += 1 print ( index ) Practice 6: one of the important application of while loop is to validate input from user prompt the user to input their gender and if its not M or F you will notify them that its wrong input and ask them to input again","title":"while loop"},{"location":"Day_1/python_basics/#hands-on","text":"Now that we have learnt the fundamentals of python programming, let's built something of our own that's useful!","title":"HANDS-ON"},{"location":"Day_1/python_basics/#nric-validator","text":"Do you know how to verify an NRIC number? Here are some guidelines: The steps involved in the computation are as follows: 1) Multiply each digit in the NRIC number by its weight i.e. 2 7 6 5 4 3 2 in order. 2) Add together the above products. 3) If the first letter i.e. UIN of the NRIC starts with T or G, add 4 to the total. 4) Find the remainder of (sum calculated above) mod 11. (total %11) 5) Compare the digit you get from last step to the following list: If the NRIC starts with F or G: 0=X, 1=W, 2=U, 3=T, 4=R, 5=Q, 6=P, 7=N, 8=M, 9=L, 10=K. If the NRIC starts with S or T: 0=J, 1=Z, 2=I, 3=H, 4=G, 5=F, 6=E, 7=D, 8=C, 9=B, 10=A After matching to the list, the letter that you get should be the last letter of the nric code ! And thus the nric number is verified! How to go about it? Do you need functions? Which data type(complex) would you use for assigning the alphabets to digits in step 5 ?","title":"NRIC validator"},{"location":"Day_1/python_basics/#optional-practice-questions","text":"Write a function to print the following pattern using for/ while loops : * ** *** **** ***** Factorial of a number n is represented by n! and is equal to 1 * 2 * 3 * .... * (n-1) * n 5! = 5 * 4 * 3 * 2 * 1 = 120 Write a program to calculate the factorial of a number given by the user","title":"Optional Practice Questions!"},{"location":"Day_2/git_data_model/","text":"Day 2 - Git's Data Model \u00b6 Data Model \u00b6 The data model of Git might not be the most essential in getting git to work but understanding what happens under the hood will allow you to have a greater understanding. Git has 3 main data types: Blob Git terminology for Files Tree Git terminology for Folders Commits Git terminology for Snapshots For each Commit, Git needs to store data on the current state of the file and more. Each commit has the following data: id A 40 char long String that is used to identify the commit. Eg. \"cf23df2207d99a74fbe169e3eba035e633b65d94\" Author Developer name that created the commit Parent id of the preceeding / parent commit Commit Message Meaningful message that the developer wrote to describe the commit Snapshot The id of the tree / folder which contains files / blobs. Key takeaways Every commit has information regarding the state of files when the commit was created. It also knows which commit preceeds it, has a message to describe the purpose of the commit and has a unique identifier (40 character long string) like \"cf23df2207d99a74fbe169e3eba035e633b65d94\" to identify it. Side note With each commit being able to be identified by their id. This makes identifying them difficult as the 40 long char strings are meaningless and not useful to humans. Therefore, git uses branch names which will map a human readable String to the commit's id. A commit / snapshot can have a branch name that can be mapped to locate which commit the branch name refers to. This gives a commit a meaningful name instead of \"cf23df2207d99a74fbe169e3eba035e633b65d94\" Branch names and branching will be covered later on but this should give you a glimpse as to why we need branch names. Example as follows:","title":"Data Model"},{"location":"Day_2/git_data_model/#day-2-gits-data-model","text":"","title":"Day 2 - Git's Data Model"},{"location":"Day_2/git_data_model/#data-model","text":"The data model of Git might not be the most essential in getting git to work but understanding what happens under the hood will allow you to have a greater understanding. Git has 3 main data types: Blob Git terminology for Files Tree Git terminology for Folders Commits Git terminology for Snapshots For each Commit, Git needs to store data on the current state of the file and more. Each commit has the following data: id A 40 char long String that is used to identify the commit. Eg. \"cf23df2207d99a74fbe169e3eba035e633b65d94\" Author Developer name that created the commit Parent id of the preceeding / parent commit Commit Message Meaningful message that the developer wrote to describe the commit Snapshot The id of the tree / folder which contains files / blobs. Key takeaways Every commit has information regarding the state of files when the commit was created. It also knows which commit preceeds it, has a message to describe the purpose of the commit and has a unique identifier (40 character long string) like \"cf23df2207d99a74fbe169e3eba035e633b65d94\" to identify it. Side note With each commit being able to be identified by their id. This makes identifying them difficult as the 40 long char strings are meaningless and not useful to humans. Therefore, git uses branch names which will map a human readable String to the commit's id. A commit / snapshot can have a branch name that can be mapped to locate which commit the branch name refers to. This gives a commit a meaningful name instead of \"cf23df2207d99a74fbe169e3eba035e633b65d94\" Branch names and branching will be covered later on but this should give you a glimpse as to why we need branch names. Example as follows:","title":"Data Model"},{"location":"Day_2/git_example/","text":"Day 2 - Git Examples \u00b6 Examples using commands we have learnt \u00b6 To better illustrate how you could visualise basic git commands. We will be going through the 2 ways of merging but starting from scratch. On our first commit, 1 snapshot in which the default branches main / master and HEAD points to. Take note main / master is a default branch created and HEAD is a pointer to show which branch you are currently on. We then use git checkout -b \"newBranch\" to create a new branch named \"newBranch\" and also move the HEAD pointer to that newly created branch. Do note that a branch is just a pointer to a commit, so creating a new branch just creates another pointer to the current commit you are on. After making some changes, we need to use git add . to add all modified file from my current directory into the staging area. This is to tell git that the added files are to be tracked. After adding files we want to commit to the staging area, we use git commit -m \"1st change\" . This tells git to create a snapshot and store a meaningful commit message named \"1 st change\". Git will then create the commit and then move the pointers newBranch and HEAD to the new commit you just created. Now to go back to the main branch, we use git checkout main to switch the HEAD pointer to the main branch. Now that we are on the main branch, we make more changes and do the same as previously mentioned to add modified files to the staging area then commit them with a meaningful message. Now we have 2 branches with 2 different feature sets / changes. We want to merge them together. Now we run git merge newBranch to merge newBranch to the current branch HEAD is on which is main in this case. Git will then do a Three-way merge since there is no linear path of commits. To illustrate a fast forward commit, refer to the left of the image for an example of a linear path of commits. You will realise that newBranch2 is simply some form of modification of the main branch. Therefore, git does not need to create another snapshot like what it did previously, but it only needs to update the main pointer to point to the commit in which newBranch2 points to.","title":"Example"},{"location":"Day_2/git_example/#day-2-git-examples","text":"","title":"Day 2 - Git Examples"},{"location":"Day_2/git_example/#examples-using-commands-we-have-learnt","text":"To better illustrate how you could visualise basic git commands. We will be going through the 2 ways of merging but starting from scratch. On our first commit, 1 snapshot in which the default branches main / master and HEAD points to. Take note main / master is a default branch created and HEAD is a pointer to show which branch you are currently on. We then use git checkout -b \"newBranch\" to create a new branch named \"newBranch\" and also move the HEAD pointer to that newly created branch. Do note that a branch is just a pointer to a commit, so creating a new branch just creates another pointer to the current commit you are on. After making some changes, we need to use git add . to add all modified file from my current directory into the staging area. This is to tell git that the added files are to be tracked. After adding files we want to commit to the staging area, we use git commit -m \"1st change\" . This tells git to create a snapshot and store a meaningful commit message named \"1 st change\". Git will then create the commit and then move the pointers newBranch and HEAD to the new commit you just created. Now to go back to the main branch, we use git checkout main to switch the HEAD pointer to the main branch. Now that we are on the main branch, we make more changes and do the same as previously mentioned to add modified files to the staging area then commit them with a meaningful message. Now we have 2 branches with 2 different feature sets / changes. We want to merge them together. Now we run git merge newBranch to merge newBranch to the current branch HEAD is on which is main in this case. Git will then do a Three-way merge since there is no linear path of commits. To illustrate a fast forward commit, refer to the left of the image for an example of a linear path of commits. You will realise that newBranch2 is simply some form of modification of the main branch. Therefore, git does not need to create another snapshot like what it did previously, but it only needs to update the main pointer to point to the commit in which newBranch2 points to.","title":"Examples using commands we have learnt"},{"location":"Day_2/git_local_concepts/","text":"Day 2 - Git Key Concepts (Local) \u00b6 Staging Area \u00b6 Before moving to how to create a snapshot / making a commit. We need to understand the git add command and the staging area. git add is the command that places certain files into the staging area. Files in the staging area will then be placed into a snapshot / commit when the git commit command is run. Why do we need the staging area? Staging area allows you to be selective in what you want git to keep track of or what to make into a commit. This allow for clean snapshots in which you as the developer can choose how to segment your newly created or edited files into seperate snapshots / commits. Commonly used git add commands: git add <filename> add file into staging area git add --all add all files in all directories into staging area git add . add all files in current directory into staging area git rm --cached <filename> remove a file from the staging area Commits \u00b6 git commit moves the files in the staging area into a snapshot / commit. This can be viewed as a milestone in your project, just like how you frequently save your word documents after every paragraph or what not. Commonly used git commit commands: git commit -m \"some descriptive commit message\" Move files in staging area to a snapshot and include a descriptive message Branching \u00b6 A branch is basically a pointer that allows for meaningful human readable text to describe a snapshot. Important to understand A branch is just a pointer that maps a meaningful text to a commit's id. Example: My branch named feature/redButton maps to a commit with an id of cf23df2207d99a74fbe169e3eba035e633b65d94 main / master Branch \u00b6 Everytime you inialize git, main or master is the default branch na,e. You can view this as the main line of development where the live code lives in. HEAD Branch \u00b6 The HEAD branch is the branch in which points to the current Branch you are currently on. Committing on a branch \u00b6 Since a branch is just a named pointer, whenever you commit on a different branch, git will create a new snapshot and then move the HEAD and the current branch forward to the new snapshot. Git checkout \u00b6 The command git checkout is used to switch and create branches. Commonly used git checkout commands: git checkout <branch name> switches branches. git checkout -b <new branch name> creates a new branch as per name passed in as arguement, then switches to it. Merging \u00b6 There are 2 ways of merging branches together which are the git merge and git rebase commands. Everytime git merges commits, there are 2 possible types of merges which are the Fast Forward and Three Way Merge . Fast Forward Merge \u00b6 When the branch is linear (No branching out). A fast forward merge will occur. Do remember that a branch is simply a pointer to a commit, so if it is linear, there is no need to create another commit, the branch only needs to update the pointer. Example as follows: Three Way Merge \u00b6 When the commits are not linear, git will create another commit and merge the branches together. Example as follows: Commonly used git merge commands: git merge <branch name> merge specific branch name into current branch. git rebase \u00b6 git rebase <branch to rebase to> stores all the differences between the branches, then resetting the branch you are currently on to a commit preceeding the branch you are rebase-ing to. It then merges all the differences into that commit. You may then perform a git merge to fast-forward the branch. Example as follows: You can view git rebase as git recording all the differences between newBranch and main then creating a new commit, then reapplying the differences into the new commit. A git merge main will then do a fast-forward merge. Take note that as previously mentioned, a branch is simply a pointer so a fast forward merge just redefines that the main branch is pointing at. Merge Conflicts \u00b6 When merging 2 or more branches, git will do auto merging, however when it comes across something it is unsure of, it will trigger a merge conflict. An example of such a conflict is as shown: You will see weird seperators on the merge conflict. The following image explains what they are and what they mean: git utilities \u00b6 Some useful git commands as listed: git status \u00b6 git status shows you the current state of your working directory in respect to your current branch. git log \u00b6 You will frequently use git log --all --graph --decorate to print out a diagram of the timeline of your commits. This is useful in visualizing your commits and where your branches are pointing at. git diff \u00b6 git diff <filename> shows the changes you made in relation to the current snapshot of the file. git diff <branch name> <filename> shows the differences as compared to a sepcific file in the specified branch.","title":"Key Concepts (Local)"},{"location":"Day_2/git_local_concepts/#day-2-git-key-concepts-local","text":"","title":"Day 2 - Git Key Concepts (Local)"},{"location":"Day_2/git_local_concepts/#staging-area","text":"Before moving to how to create a snapshot / making a commit. We need to understand the git add command and the staging area. git add is the command that places certain files into the staging area. Files in the staging area will then be placed into a snapshot / commit when the git commit command is run. Why do we need the staging area? Staging area allows you to be selective in what you want git to keep track of or what to make into a commit. This allow for clean snapshots in which you as the developer can choose how to segment your newly created or edited files into seperate snapshots / commits. Commonly used git add commands: git add <filename> add file into staging area git add --all add all files in all directories into staging area git add . add all files in current directory into staging area git rm --cached <filename> remove a file from the staging area","title":"Staging Area"},{"location":"Day_2/git_local_concepts/#commits","text":"git commit moves the files in the staging area into a snapshot / commit. This can be viewed as a milestone in your project, just like how you frequently save your word documents after every paragraph or what not. Commonly used git commit commands: git commit -m \"some descriptive commit message\" Move files in staging area to a snapshot and include a descriptive message","title":"Commits"},{"location":"Day_2/git_local_concepts/#branching","text":"A branch is basically a pointer that allows for meaningful human readable text to describe a snapshot. Important to understand A branch is just a pointer that maps a meaningful text to a commit's id. Example: My branch named feature/redButton maps to a commit with an id of cf23df2207d99a74fbe169e3eba035e633b65d94","title":"Branching"},{"location":"Day_2/git_local_concepts/#main-master-branch","text":"Everytime you inialize git, main or master is the default branch na,e. You can view this as the main line of development where the live code lives in.","title":"main / master Branch"},{"location":"Day_2/git_local_concepts/#head-branch","text":"The HEAD branch is the branch in which points to the current Branch you are currently on.","title":"HEAD Branch"},{"location":"Day_2/git_local_concepts/#committing-on-a-branch","text":"Since a branch is just a named pointer, whenever you commit on a different branch, git will create a new snapshot and then move the HEAD and the current branch forward to the new snapshot.","title":"Committing on a branch"},{"location":"Day_2/git_local_concepts/#git-checkout","text":"The command git checkout is used to switch and create branches. Commonly used git checkout commands: git checkout <branch name> switches branches. git checkout -b <new branch name> creates a new branch as per name passed in as arguement, then switches to it.","title":"Git checkout"},{"location":"Day_2/git_local_concepts/#merging","text":"There are 2 ways of merging branches together which are the git merge and git rebase commands. Everytime git merges commits, there are 2 possible types of merges which are the Fast Forward and Three Way Merge .","title":"Merging"},{"location":"Day_2/git_local_concepts/#fast-forward-merge","text":"When the branch is linear (No branching out). A fast forward merge will occur. Do remember that a branch is simply a pointer to a commit, so if it is linear, there is no need to create another commit, the branch only needs to update the pointer. Example as follows:","title":"Fast Forward Merge"},{"location":"Day_2/git_local_concepts/#three-way-merge","text":"When the commits are not linear, git will create another commit and merge the branches together. Example as follows: Commonly used git merge commands: git merge <branch name> merge specific branch name into current branch.","title":"Three Way Merge"},{"location":"Day_2/git_local_concepts/#git-rebase","text":"git rebase <branch to rebase to> stores all the differences between the branches, then resetting the branch you are currently on to a commit preceeding the branch you are rebase-ing to. It then merges all the differences into that commit. You may then perform a git merge to fast-forward the branch. Example as follows: You can view git rebase as git recording all the differences between newBranch and main then creating a new commit, then reapplying the differences into the new commit. A git merge main will then do a fast-forward merge. Take note that as previously mentioned, a branch is simply a pointer so a fast forward merge just redefines that the main branch is pointing at.","title":"git rebase"},{"location":"Day_2/git_local_concepts/#merge-conflicts","text":"When merging 2 or more branches, git will do auto merging, however when it comes across something it is unsure of, it will trigger a merge conflict. An example of such a conflict is as shown: You will see weird seperators on the merge conflict. The following image explains what they are and what they mean:","title":"Merge Conflicts"},{"location":"Day_2/git_local_concepts/#git-utilities","text":"Some useful git commands as listed:","title":"git utilities"},{"location":"Day_2/git_local_concepts/#git-status","text":"git status shows you the current state of your working directory in respect to your current branch.","title":"git status"},{"location":"Day_2/git_local_concepts/#git-log","text":"You will frequently use git log --all --graph --decorate to print out a diagram of the timeline of your commits. This is useful in visualizing your commits and where your branches are pointing at.","title":"git log"},{"location":"Day_2/git_local_concepts/#git-diff","text":"git diff <filename> shows the changes you made in relation to the current snapshot of the file. git diff <branch name> <filename> shows the differences as compared to a sepcific file in the specified branch.","title":"git diff"},{"location":"Day_2/git_overview/","text":"Day 2 - Overview of Git \u00b6 You may use this youtube playlist to accompany the lecture notes: Link to Youtube Playlist Lecture Notes: Download lecture pdf file Why should you learn Git? \u00b6 Git is the de facto version control system in which most developers and companies use. Learning the basics will greatly enhance your internship / career in the future. It will also enable you to collaborate easily with other open sourced projects and even your school projects. Why do we need git? \u00b6 Git is an open sourced version control system. It helps us organize our codebase into snapshots so that one can revert back or combine different snapshots easily. We all have done this too, just in a less efficient manner such as : This can get confusing and is rather prone to human errors. Therefore this is where git comes in to help us organize different stages of development and bug fixes. Git vs Github \u00b6 Git is a version control system that works without Github in which it saves a local copy of the snapshots and Github is like an online service that hosts Git repositories which can be seen like a google drive where people can freely upload their local Git repositories. How git works? \u00b6 Git models the history and timeline of a bunch of files and folders using a series of snapshots. Each snapshot can be viewed as a state of the entire folder in which git is tracking. It contains information about every file and folder. Tldr Git works by taking a bunch of snapshots of the state of files. This is like saving your game progress at different checkpoints so you can track your progress or even revert back when needed.","title":"Overview"},{"location":"Day_2/git_overview/#day-2-overview-of-git","text":"You may use this youtube playlist to accompany the lecture notes: Link to Youtube Playlist Lecture Notes: Download lecture pdf file","title":"Day 2 - Overview of Git"},{"location":"Day_2/git_overview/#why-should-you-learn-git","text":"Git is the de facto version control system in which most developers and companies use. Learning the basics will greatly enhance your internship / career in the future. It will also enable you to collaborate easily with other open sourced projects and even your school projects.","title":"Why should you learn Git?"},{"location":"Day_2/git_overview/#why-do-we-need-git","text":"Git is an open sourced version control system. It helps us organize our codebase into snapshots so that one can revert back or combine different snapshots easily. We all have done this too, just in a less efficient manner such as : This can get confusing and is rather prone to human errors. Therefore this is where git comes in to help us organize different stages of development and bug fixes.","title":"Why do we need git?"},{"location":"Day_2/git_overview/#git-vs-github","text":"Git is a version control system that works without Github in which it saves a local copy of the snapshots and Github is like an online service that hosts Git repositories which can be seen like a google drive where people can freely upload their local Git repositories.","title":"Git vs Github"},{"location":"Day_2/git_overview/#how-git-works","text":"Git models the history and timeline of a bunch of files and folders using a series of snapshots. Each snapshot can be viewed as a state of the entire folder in which git is tracking. It contains information about every file and folder. Tldr Git works by taking a bunch of snapshots of the state of files. This is like saving your game progress at different checkpoints so you can track your progress or even revert back when needed.","title":"How git works?"},{"location":"Day_2/git_remote_concepts/","text":"Day 2 - Working with github concepts \u00b6 Remote \u00b6 Git works locally on our computer, but what if we want to collaborate with other developers and would like to share the git folder. For this, we use github which hosts git folders. To link a git folder to a remote git repository, we use git remote add <name of remote> <url link of remote git repo> . This can be seen as syncing your git folder with a remote computer that contains the same git repo. Push / Pull / Fetch \u00b6 In order to send updates to the remote repo, we use git push <remote repo name> <branch name> In order to get updates from the remote repo, we use git pull <remote repo name> <branch name> Another way of getting updates from the remote repo, we also can use git fetch <remote repo name> <branch name> git pull vs git fetch The differences between git pull and git fetch , is that git pull automatically merges the changes into your local directory while git fetch gets all the changes and stores in in another commit in a branch named FETCH_HEAD in which you can later combine using git merge FETCH_HEAD . Therefore git pull actually calls git fetch and git merge FETCH_HEAD automatically. Clone \u00b6 To download repositories on github as a git repo, we use git clone <repo url> . A url can be accessed as follows: Running git clone <repo url> will download the entire repo as a git repo instead of just a zip folder. gitignore \u00b6 If we have files that we want git to always ignore and not track them, we use a .gitignore file to list down specific files. Why does the file name have a dot infront? File with a . infront are called dotfiles . They are hidden files are hidden from the OS and even the ls command doesn't show it. In fact, we need to use ls -a in which the -a flag tells the command to include hidden files or \"all\" files. dotfiles are generally used for config files such as gitignore in this case. .gitignore uses a globbing patterns to match file names. Commonly used pattern are such as: **/folderName : every file that have a parent directory named folderName such as folderName/apiKeys , secret/folderName/apiKeys *.log : Any file that has .log in it such as apiKeys.log No need to memorise such patterns. Google is always your bestfriend. Link to more information on gitignore patterns gitignore templates Licenses \u00b6 Once your work is made public, it must have a license as all creative work are eligible for intellectual property and copyright protection. A license.txt file in the base directory tells people how and what they are able to do with your work. For speicific cases, please refer to this link to choose a license . Otherwise, the MIT license is the most common as it allows anyone to do anything with your work. If unsure Always just refer to link to choose a license as it lists out each case with specific details.","title":"Key Concepts (Remote)"},{"location":"Day_2/git_remote_concepts/#day-2-working-with-github-concepts","text":"","title":"Day 2 - Working with github concepts"},{"location":"Day_2/git_remote_concepts/#remote","text":"Git works locally on our computer, but what if we want to collaborate with other developers and would like to share the git folder. For this, we use github which hosts git folders. To link a git folder to a remote git repository, we use git remote add <name of remote> <url link of remote git repo> . This can be seen as syncing your git folder with a remote computer that contains the same git repo.","title":"Remote"},{"location":"Day_2/git_remote_concepts/#push-pull-fetch","text":"In order to send updates to the remote repo, we use git push <remote repo name> <branch name> In order to get updates from the remote repo, we use git pull <remote repo name> <branch name> Another way of getting updates from the remote repo, we also can use git fetch <remote repo name> <branch name> git pull vs git fetch The differences between git pull and git fetch , is that git pull automatically merges the changes into your local directory while git fetch gets all the changes and stores in in another commit in a branch named FETCH_HEAD in which you can later combine using git merge FETCH_HEAD . Therefore git pull actually calls git fetch and git merge FETCH_HEAD automatically.","title":"Push / Pull / Fetch"},{"location":"Day_2/git_remote_concepts/#clone","text":"To download repositories on github as a git repo, we use git clone <repo url> . A url can be accessed as follows: Running git clone <repo url> will download the entire repo as a git repo instead of just a zip folder.","title":"Clone"},{"location":"Day_2/git_remote_concepts/#gitignore","text":"If we have files that we want git to always ignore and not track them, we use a .gitignore file to list down specific files. Why does the file name have a dot infront? File with a . infront are called dotfiles . They are hidden files are hidden from the OS and even the ls command doesn't show it. In fact, we need to use ls -a in which the -a flag tells the command to include hidden files or \"all\" files. dotfiles are generally used for config files such as gitignore in this case. .gitignore uses a globbing patterns to match file names. Commonly used pattern are such as: **/folderName : every file that have a parent directory named folderName such as folderName/apiKeys , secret/folderName/apiKeys *.log : Any file that has .log in it such as apiKeys.log No need to memorise such patterns. Google is always your bestfriend. Link to more information on gitignore patterns gitignore templates","title":"gitignore"},{"location":"Day_2/git_remote_concepts/#licenses","text":"Once your work is made public, it must have a license as all creative work are eligible for intellectual property and copyright protection. A license.txt file in the base directory tells people how and what they are able to do with your work. For speicific cases, please refer to this link to choose a license . Otherwise, the MIT license is the most common as it allows anyone to do anything with your work. If unsure Always just refer to link to choose a license as it lists out each case with specific details.","title":"Licenses"},{"location":"Day_2/python%20oop/","text":"Objected Oriented Programming \u00b6 1. Functions \u00b6 1.1. What are functions and why do we need them? \u00b6 Lets say that you are watching TV. Every time you want to change the channel, you will use the same remote control. It would be quite inconvenient if you had to make a new remote control each time you wanted to change the channel. Similarly, in programming, you might want to write a piece of code that you need to re-use multiple times in different parts of your program. For example, lets say that you write a program to find the largest number in a list: list_of_numbers = [ 32 , 88 , 3 , 48 , 87 , 22 ] max = list_of_numbers [ 0 ] for number in list_of_numbers : if max < number : max = number print ( max ) But what if you need to find the largest value in 10 different lists? Would it be feasable to rewrite the same code again 10 different times? This is where functions come into the picture. They allow you to re-use the same piece of code again and again, however many times you might want. More formally, A function is a block of code that allows you to to perform a specific action. It is modular, and re-usable as many times as you want. Some functions might even give you back a value. For example, the same code written using functions would look something like: # this line is known as the function prototype. # the variables inside the brackets are known as formal parameters or formal arguments def max_value ( list_of_numbers ): # the word 'def' is short for define. It means you are defining a function called 'max_value' # In python, it is a convention to write function names in 'snake case' # snake case means that the each word is in lower case, and separated by underscores. # Example: this_is_snake_case max = list_of_numbers [ 0 ] for number in list_of_numbers : if max < number : max = number # the word 'return' here tells python that this function needs to give you back the value of 'max' return max list1 = [ 32 , 88 , 3 , 48 , 87 , 22 ] list2 = [ 44 , 26 , 56 , 90 , 12 , 35 ] list3 = [ 96 , 43 , 30 , 12 , 37 , 26 ] # this is known as a function call and the variables passed to the function are called actual parameters or actual arguments max1 = max_value ( list1 ) max2 = max_value ( list2 ) max3 = max_value ( list3 ) print ( max1 ) print ( max2 ) print ( max3 ) A function does not have to necessarily return a value: def display_elements ( a_list ): for element in a_list : print ( element ) list1 = [ 32 , 88 , 3 , 48 , 87 , 22 ] list2 = [ 44 , 26 , 56 , 90 , 12 , 35 ] list3 = [ 96 , 43 , 30 , 12 , 37 , 26 ] print ( display_elements ( list1 )) print ( display_elements ( list2 )) print ( display_elements ( list3 )) Output: 32 88 3 48 87 22 None 44 26 56 90 12 35 None 96 43 30 12 37 26 None Why does it print a None between the elements of the lists? Remember, these functions don't return any values! Thus, print(displayElementsOf(list1)) doesn't actually have something to print! Note: A function does not execute the rest of its code if a return statement is encountered def function ( number ): return number * 2 print ( number / 2 ) print ( function ( 5 )) Output: 10 1.2. Excersise: Write a function to calculate the factorial of a number \u00b6 The factorial of a number n, represented by n! is given by n*(n-1)*(n-2)*...*1. For example, 5! = 5*4*3*2*1 = 120 1.3. Different types of arguments \u00b6 In python, there are 6 different types of arguments that a function can take. They are: 1.3.1. Required Arguments: are arguments that MUST ALWAYS be passed to the function. def add ( a , b ): # a and b are required arguments return a + b print ( add ( 3 , 5 )) # prints 8 1.3.2. Optional Arguments: are arguments that may not be passed to the function. def add ( a , b , c = 0 ): # a and b are required arguments while c is an optional argument. All arguments initialised with a default value are optional return a + b + c print ( add ( 3 , 5 )) # prints 8 print ( add ( 3 , 5 , 5 )) # prints 13 Note: All optional arguments are always written after the positional arguments in the function prototype 1.3.3. Positional Arguments: are arguments that are passed using their position to the function. def simple_interest ( principle , rate , time ): # principle, rate and time are all required arguments return principle * rate / 100 * time # since they are passed to the function by their position, i.e. principle is 1000, rate is 15 and time is 5 print ( simple_interest ( 1000 , 15 , 5 )) # prints 750.0 Note: In the example in point 2, the variable c is a positional argument that is optional! 1.3.4. Keword Arguments: are arguments that are passed using their name to the function. def simple_interest ( rate , time , principle = 100 ): # rate and time are all required arguments while principle is an optional argument with a default value of 100 return principle * rate / 100 * time # since they are passed to the function print ( simple_interest ( rate = 15 , principle = 1000 , time = 5 )) # prints 750.0 print ( simple_interest ( 15 , 5 )) # prints 75.0 print ( simple_interest ( 15 , principle = 1000 , time = 5 )) # prints 750.0 Note1: Keyword arguments are always passed to the function after positional arguments! Thus, simple_interest(15, time = 5, 1000) isn't allowed, but simple_interest(15, 5, principle = 1000) is Note2: An argument cannot be called as both a positonal and a keyword argument IN THE SAME function call! simple_interest(15, 5, rate = 15) would not be valid since it calls rate as both a positional and a keyword argument 1.3.5. Arbitrary Arguments(*args): When an unknown or \"arbitrary\" number of arguments are passed to a function, they are known as Arbitrary arguments def add_multiply ( * nums , multiply = 1 ): # nums is a required argument. the * denotes that it will accept an arbitrary number of arguments. # nums will be a list of all the arguments provided sum = 0 for num in nums : sum += num return sum * multiply # add up all these numbers print ( add_multiply ( 5 , 6 , 2 , 4 , 2 )) # prints 19 # add up all these numbers and also multiply by 2 print ( add_multiply ( 5 , 6 , 2 , 4 , 2 , 3 , 5 , multiply = 2 )) # prints 54 Note1: Other arguments may follow an arbitrary argument but then that argument MUST ALWAYS be called as a keyword argument Note2: Other positional arguments may preceed an arbitrary argument Note3: An arbitrary argument CANNOT be called as a keyword argument! 1.3.6. Arbitrary Keyword Arguments(**kwargs): When an unknown or \"arbitrary\" number of keyword arguments are passed to a function, they are known as Arbitrary arguments def display_works ( author , ** works ): # works is a required argument. the ** denotes that it will accept an arbitrary number of keyword arguments. # works will be a dictionary of all the keyword arguments and their values provided. for key in works : print ( f \"( { key } , { works [ key ] } )\" ) print ( author ) display_works ( \"Roald Dahl\" , book1 = \"Charlie and the Chocolate Factory\" , book2 = \"Matilda\" ) Note1: No arguments can follow arbitrary keyword arguments. Note2: Any number of keyword or positional arguments can preceed arbitrary keyword arguments. def add_multiply ( * nums , multiply = 1 ): # nums is a required argument. the * denotes that it will accept an arbitrary number of arguments. # nums will be a list of all the arguments provided sum = 0 for num in nums : sum += num return sum * multiply # add up all these numbers print ( add_multiply ( 5 , 6 , 2 , 4 , 2 )) # prints 19 # add up all these numbers and also multiply by 2 print ( add_multiply ( 5 , 6 , 2 , 4 , 2 , 3 , 5 , multiply = 2 )) # prints 54 1.4 Type Hints \u00b6 When writing functions with a lot of parameters and variable names that might be unintuitive, it is a good idea to use type hints! type hints allow the person writing the function to tell the user what the expected data types of all the arguments being passed into it are For example: # this tells the user than height is a float, weight is an int and that this function is meant to return a float as well def calculateBMI ( height : float , weight : int ) -> float : return weight / (( height / 100 ) ** 2 ) print ( calculateBMI ( 182 , 80 )) 1.5 What is recursion, and why do we need it? \u00b6 Lets take the factorial from the previous excersie as an example. We have learnt that n! = n*(n-1)*(n-2)*...*1 Similarly, (n-1)! = (n-1)*(n-2)*...*1 But, notice that from these two equations we can actually write that n! = n*(n-1)! So if you were being introduced to the factorial for the first time, and you were just told that n! = n*(n-1)! would this be enough information to find out the factorial of any number? Try computing 3! just by using the definition that n! = n*(n-1)!. If you actually tried to do that, you would realise that its actually not possible because with that definition, you don't know when to stop! 3! = 3*2! 2! = 2*1! 1! = 1*0! 0! = 0*(-1)! ... This means that other than the fact that n! = n*(n-1)! we also need a point to stop at. Lets say that you are now told that 0! = 1. With that information in mind, we can actually compute 3! 3! = 3*2! 2! = 2*1! 1! = 1*0! and now, we know that 0! = 1, so now we use that in the last equation and work our way back up! 1! = 1 and then using this, 2! = 2, and then using this, it is found that 3! = 6 This process of defining a process in its own terms is known as recursion! The \"stopping point\" at which we stop going down and start to work back up is known as the base case! So can we do something like this with functions? Yes! def factorial ( number ): # remember to write a base case! # If you forget, you're program will be stuck in an infinite loop of recursion! if number == 0 : return 1 # the recursive case: return number * factorial ( number - 1 ) 1.6 Excersise: What does this piece of code output? \u00b6 def function ( number ): if number >= 1 : print ( number ) function ( number - 1 ) print ( number ) function ( 3 ) Remember: A function will always execute ALL of its code UNLESS a return statement is encountered. 2. Classes and Objects \u00b6 2.1. What is Object Oriented Programming, and why do we need it? \u00b6 We come across a lot of different objects in our daily life. Each object has its own properties, some features that define it. Lets take a pen for example. What are the properties of a pen? Its colour, its size, its kind (ball-point, fountain-point, gel-ink) and maybe the name of its owner. Another example is a textbook. A textbook has a size, it has a subject, it has a length (the number of pages) and it has some information inside of it. Now the information inside a textbook is organised into named chapters. For example, a maths text book might contain chapters like \"sets\", \"trigonometery\", \"calculus\" and so on, and if you want someone to read or go through a chapter, you'd say something like \"go through the chapter on calculus\". Now imagine that you are a programmer who wants to write code that describes a pen, or a textbook... how could you go about writing code that expresses these properties discussed above? You might try writing code that looks similar to this: pen_colour = \"red\" pen_size = 0.5 pen_kind = \"ball\" pen_owner = \"John\" # wouldn't you want a way to see the info about your pen? Lets write a function to do that! def display_information ( colour , size , kind , owner ): print ( \"Colour : \" + colour ) print ( \"Size : \" + str ( size )) print ( \"Kind : \" + kind ) print ( \"Owner : \" + owner ) print () display_information ( pen_colour , pen_size , pen_kind , pen_owner ) Sure, that would work for one pen, but some questions one might have are: What if you wanted to make an unknown number of pens? How would someone know how many variables to declare? What if you had a more complicated object with 100 properties? Would it be feasable to manually declare 100 variables for every object that you might need to create? This is where classes come into the picture. So far we have learnt about the primitive data types in python, primitive meaning that they are in-built, simple data types which python provides to us. Now we are moving on to custom data types, data types that are defined by you, the programmer! 2.2. What are classes, and why do we need them? \u00b6 So now, we want to create our own data types, a data type that would allow us to describe a pen, or any other object effectively, using code. This is exactly what a class allows us to do! A class is basically a blue-print for creating an object, it tells us the defining properties of the object, and it also tells us what functions the object can perform. Following the class blue-print allows us to create \"instances\" of that class. An object of a class, the realisation of the blueprint, is known as an instance of the class. class Pen : # remember the properties of the pen we discussed? A colour, a size, a kind, an owner def __init__ ( pen , col , sz , knd , own ): pen . colour = col pen . size = sz pen . kind = knd pen . owner = own # This special function __init__ is known as a constructor, this is the \"method\" by which the object will be \"constructed\", # this is the essence of the blue-print! # wouldn't you want a way to see the properties of a pen you made as well? # you can write functions in a class that can work with the instances of the class. These functions are known as 'member # functions' of the class or 'methods'. # methods are always functions that work on objects of a specific class. A method cannot be used without an object # All methods of a class are unique to that class, and cannot be used on objects from other classes! # for example, you could have a method called read() that reads the contents of a text book but you # cannot use that method on a pen, because it doesn't make sense to read a pen! def display_information ( pen ): print ( \"Colour : \" + pen . colour ) print ( \"Size : \" + str ( pen . size )) print ( \"Kind : \" + pen . kind ) print ( \"Owner : \" + pen . owner ) print () # But a class is just a blue-print for creating a pen, it tells us which properties a pen is supposed to have # But it is NOT the pen itself! # To actually create a pen, we need to use the blue-print and specify all the properties of the specifc pen we want to create: A = Pen ( \"red\" , 0.5 , \"marker\" , \"John\" ) # When we do this, python calls the constructor and says, hey constructor, # construct me a Pen with its colour as \"red\", its size as 0.5, its kind as \"marker\" and let its owner be \"John\" # this process of creating an object from its class is known as instantiation A . display_information () # display this marker's information # And now that we actually have a pen class, remember that we can make AS MANY pens as we want! B = Pen ( \"blue\" , 0.1 , \"ball\" , \"John\" ) C = Pen ( \"black\" , 0.2 , \"fountain\" , \"Robin\" ) D = Pen ( \"red\" , 0.1 , \"gel\" , \"Joe\" ) E = Pen ( \"green\" , 0.1 , \"gel\" , \"Robert\" ) # since a method works on a particular instance of a class, it must be called by using the dot operator, on that specific object. B . display_information () C . display_information () D . display_information () E . display_information () 2.3. Classes, conventionally \u00b6 All programmers mutually agree to follow some rules, called conventions that are not necessary, but nice to follow while writing classes and make your code more readable to a usual programmer: class Pen : # typically, the object is called \"self\" in the functions that work with it # it is also common to give the same names to the function parameters as the properties of the object itself def __init__ ( self , colour , size , kind , owner ): self . colour = colour self . size = size self . kind = kind self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Size : \" + str ( self . size )) print ( \"Kind : \" + self . kind ) print ( \"Owner : \" + self . owner ) print () 2.4. Excersise: Write a class that describes a bicycle object \u00b6 Which properties should a bicycle object have? Colour (red, blue, white, etc) Material (steel, aluminum, plastic, wood, etc) Size (small, medium, large) Height of the seat (in m) Gear ratio (1, 2.5, 4, etc) Diameter of the wheels (in cm) Does it have a basket Does it have a Bell Do its wheels have sufficient air Is the chain of the bicycle routed properly What functions should a bicycle have? Change gear ratio Adjust seat height Route chain Pump air into the wheels Find the speed of the bicycle (in m/s) when a peddling speed (in rpm) is provided (Hint: The speed of a bicycle with a peddling speed in rpm is given by: (peddling_speed/60)*gear_ratio*((2*\u03c0*wheel_diameter/2)/100) ) Would you make this with or without using a class? 2.5. What makes classes so good? \u00b6 Reusability: The same class can be used to make as many objects as you want Modularity: The code becomes incredibly modular, and it is easy for a programmer to debug the code in case there are any bugs Clarity of code: Due to the code being modular, it is easier for others to read and understand the code Better organisation: The data can be clearly and neatly organised for more complex objects Data Abstraction: This is the process of hiding the implementation details from the user, allowing them to focus on the functionality instead. Example: you don't need to know a smartphone works internally to be able to use it. The details about its circuits, its workings are hidden from you, the user! Instead, the smartphone provides you with functions (call, message, surf the internet) only. Example in python: The functions like math.sin() and math.cos() can be used to find out the sine or cosine of an angle, but they do not tell you how the calcualtion is actually done. Those implementation details are hidden from you, the user and you only need to focus on the functionality! 2.6. An object can also have other objects as its properties \u00b6 class Pen : def __init__ ( self , colour , size , kind , owner ): self . colour = colour self . size = size self . kind = kind self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Size : \" + str ( self . size )) print ( \"Kind : \" + self . kind ) print ( \"Owner : \" + self . owner ) print () class Pencil : def __init__ ( self , colour , shade , owner ): self . colour = colour self . shade = shade self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Shade : \" + str ( self . shade )) print ( \"Owner : \" + self . owner ) print () class Stationary : def __init__ ( self , pen , pencil ): self . pen = pen self . pencil = pencil def display_information ( self ): print ( \"The Pen: \" ) self . pen . display_information () print ( \"The Pencil: \" ) self . pencil . display_information () A = Stationary ( Pen ( \"blue\" , 0.1 , \"ball\" , \"John\" ), Pencil ( \"black\" , \"HB\" , \"John\" )) A . display_information () 3. Inheritance \u00b6 3.1. What is inheritance, and why do we need it? \u00b6 Lets say that there is a Person. Now each person has some defining properties, like their name, age, sex, height, weight. A person could be a student and in that case, they would have some additional defining properties, for example the school they attend, their id number, their year, their section and their seat number. Now imagine that you are a programmer trying to describe a student using code... how could you go about writing code that expresses these properties discussed above? Keep in mind that a class Person with the properties name, age, sex, height and weight already exists. You might think of a few different things that can be done here: One option is to have a person object as a part of the student object, like so: class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) class Student1 : def __init__ ( self , person , school , id_no , seat_no , year , section ): self . person = person self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): self . person . display_information () print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) print () A = Student1 ( Person ( \"John\" , 15 , \"male\" , 160 , 60 ), \"SUTD\" , 1024 , 32 , 2 , \"A\" ) print ( A . person . name + \"'s age: \" + str ( A . person . age )) A . display_information () Another option might be to declare all of the properties of a person again along with the additional properties of a student # class Person here is unused, basically making the already existing class redundant class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) class Student2 : def __init__ ( self , name , age , sex , height , weight , school , id_no , seat_no , year , section ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) print () # when there are a lot of function parameters, it is nice to specify which parameters correspond to what # values for better readability and clarity B = Student2 ( name = \"Robert\" , age = 14 , sex = \"male\" , height = 160 , weight = 65 , school = \"SUTD\" , id_no = 1025 , seat_no = 12 , year = 1 , section = \"A\" ) print ( B . name + \"'s age: \" + str ( B . age )) B . display_information () The first approach works, but the syntax looks a bit unintuitive, doesn't it? This is because to create a student object, you have to first make a Person object and then provide that person object to the student constructor, like so A = Student1(Person(\"John\", 15, \"male\", 170, 70), \"SUTD\", 1024, 32, 2, \"A\") Also, to access a student's name and age, you have to do A.person.name and A.person.age ... wouldn't A.name and A.age make more sense? The 2 nd approach fixes this issue but it is also a bit tedious because you have to manually declare all properties of a person inside the student constructor... What if there were not 5, but 100 different properties associated with a person? It would be too unfeasable to manually rewrite them. This is where inheritance comes into the picture. Inheritance literally allows us to \"inherit\" the properties of one class (called the super class) into another class (called the sub class) # Super/Parent class class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) # Base/Sub class class Student ( Person ): def __init__ ( self , name , age , sex , height , weight , school , id_no , seat_no , year , section ): Person . __init__ ( self , name , age , sex , height , weight ) self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): Person . display_information ( self ) print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) # when there are a lot of function parameters, it is nice to specify which parameters correspond to what # values for better readability and clarity A = Student ( name = \"Robin\" , age = 16 , sex = \"male\" , height = 180 , weight = 75 , school = \"SUTD\" , id_no = 1023 , seat_no = 3 , year = 3 , section = \"A\" ) print ( A . name + \"'s age: \" + str ( A . age )) A . display_information () 3.2 Excersise: Given a class computer, Write a subclass laptop and desktop with the given additional properties: \u00b6 A computer object has the following properties: CPU Type Storage Type Storage Quantity (in GB) RAM (in GB) GPU Type Write a class for laptop and desktop objecta that have the above properties, and the additional properties listed below: Desktop: Monitor Monitor Resolution Keyboard Mouse Laptop: Monitor Resolution is it a touchscreen? Also write a function that displays all this information class Computer : def __init__ ( self , cpu : str , storage_type : str , storage : float , ram : float , gpu : str ): # type hints can also be given to a class' data members self . cpu : str = cpu self . storage_type : str = storage_type self . storage : float = storage self . ram : float = ram self . gpu : str = gpu def display_information ( self ): print ( \"The CPU type is : \" + self . cpu ) print ( \"The Storage type is : \" + self . storage_type ) print ( \"The Stroage is : \" + str ( self . storage )) print ( \"The RAM is : \" + str ( self . ram )) print ( \"The GPU is : \" + self . gpu )","title":"Python OOP"},{"location":"Day_2/python%20oop/#objected-oriented-programming","text":"","title":"Objected Oriented Programming"},{"location":"Day_2/python%20oop/#1-functions","text":"","title":"1. Functions"},{"location":"Day_2/python%20oop/#11-what-are-functions-and-why-do-we-need-them","text":"Lets say that you are watching TV. Every time you want to change the channel, you will use the same remote control. It would be quite inconvenient if you had to make a new remote control each time you wanted to change the channel. Similarly, in programming, you might want to write a piece of code that you need to re-use multiple times in different parts of your program. For example, lets say that you write a program to find the largest number in a list: list_of_numbers = [ 32 , 88 , 3 , 48 , 87 , 22 ] max = list_of_numbers [ 0 ] for number in list_of_numbers : if max < number : max = number print ( max ) But what if you need to find the largest value in 10 different lists? Would it be feasable to rewrite the same code again 10 different times? This is where functions come into the picture. They allow you to re-use the same piece of code again and again, however many times you might want. More formally, A function is a block of code that allows you to to perform a specific action. It is modular, and re-usable as many times as you want. Some functions might even give you back a value. For example, the same code written using functions would look something like: # this line is known as the function prototype. # the variables inside the brackets are known as formal parameters or formal arguments def max_value ( list_of_numbers ): # the word 'def' is short for define. It means you are defining a function called 'max_value' # In python, it is a convention to write function names in 'snake case' # snake case means that the each word is in lower case, and separated by underscores. # Example: this_is_snake_case max = list_of_numbers [ 0 ] for number in list_of_numbers : if max < number : max = number # the word 'return' here tells python that this function needs to give you back the value of 'max' return max list1 = [ 32 , 88 , 3 , 48 , 87 , 22 ] list2 = [ 44 , 26 , 56 , 90 , 12 , 35 ] list3 = [ 96 , 43 , 30 , 12 , 37 , 26 ] # this is known as a function call and the variables passed to the function are called actual parameters or actual arguments max1 = max_value ( list1 ) max2 = max_value ( list2 ) max3 = max_value ( list3 ) print ( max1 ) print ( max2 ) print ( max3 ) A function does not have to necessarily return a value: def display_elements ( a_list ): for element in a_list : print ( element ) list1 = [ 32 , 88 , 3 , 48 , 87 , 22 ] list2 = [ 44 , 26 , 56 , 90 , 12 , 35 ] list3 = [ 96 , 43 , 30 , 12 , 37 , 26 ] print ( display_elements ( list1 )) print ( display_elements ( list2 )) print ( display_elements ( list3 )) Output: 32 88 3 48 87 22 None 44 26 56 90 12 35 None 96 43 30 12 37 26 None Why does it print a None between the elements of the lists? Remember, these functions don't return any values! Thus, print(displayElementsOf(list1)) doesn't actually have something to print! Note: A function does not execute the rest of its code if a return statement is encountered def function ( number ): return number * 2 print ( number / 2 ) print ( function ( 5 )) Output: 10","title":"1.1. What are functions and why do we need them?"},{"location":"Day_2/python%20oop/#12-excersise-write-a-function-to-calculate-the-factorial-of-a-number","text":"The factorial of a number n, represented by n! is given by n*(n-1)*(n-2)*...*1. For example, 5! = 5*4*3*2*1 = 120","title":"1.2. Excersise: Write a function to calculate the factorial of a number"},{"location":"Day_2/python%20oop/#13-different-types-of-arguments","text":"In python, there are 6 different types of arguments that a function can take. They are: 1.3.1. Required Arguments: are arguments that MUST ALWAYS be passed to the function. def add ( a , b ): # a and b are required arguments return a + b print ( add ( 3 , 5 )) # prints 8 1.3.2. Optional Arguments: are arguments that may not be passed to the function. def add ( a , b , c = 0 ): # a and b are required arguments while c is an optional argument. All arguments initialised with a default value are optional return a + b + c print ( add ( 3 , 5 )) # prints 8 print ( add ( 3 , 5 , 5 )) # prints 13 Note: All optional arguments are always written after the positional arguments in the function prototype 1.3.3. Positional Arguments: are arguments that are passed using their position to the function. def simple_interest ( principle , rate , time ): # principle, rate and time are all required arguments return principle * rate / 100 * time # since they are passed to the function by their position, i.e. principle is 1000, rate is 15 and time is 5 print ( simple_interest ( 1000 , 15 , 5 )) # prints 750.0 Note: In the example in point 2, the variable c is a positional argument that is optional! 1.3.4. Keword Arguments: are arguments that are passed using their name to the function. def simple_interest ( rate , time , principle = 100 ): # rate and time are all required arguments while principle is an optional argument with a default value of 100 return principle * rate / 100 * time # since they are passed to the function print ( simple_interest ( rate = 15 , principle = 1000 , time = 5 )) # prints 750.0 print ( simple_interest ( 15 , 5 )) # prints 75.0 print ( simple_interest ( 15 , principle = 1000 , time = 5 )) # prints 750.0 Note1: Keyword arguments are always passed to the function after positional arguments! Thus, simple_interest(15, time = 5, 1000) isn't allowed, but simple_interest(15, 5, principle = 1000) is Note2: An argument cannot be called as both a positonal and a keyword argument IN THE SAME function call! simple_interest(15, 5, rate = 15) would not be valid since it calls rate as both a positional and a keyword argument 1.3.5. Arbitrary Arguments(*args): When an unknown or \"arbitrary\" number of arguments are passed to a function, they are known as Arbitrary arguments def add_multiply ( * nums , multiply = 1 ): # nums is a required argument. the * denotes that it will accept an arbitrary number of arguments. # nums will be a list of all the arguments provided sum = 0 for num in nums : sum += num return sum * multiply # add up all these numbers print ( add_multiply ( 5 , 6 , 2 , 4 , 2 )) # prints 19 # add up all these numbers and also multiply by 2 print ( add_multiply ( 5 , 6 , 2 , 4 , 2 , 3 , 5 , multiply = 2 )) # prints 54 Note1: Other arguments may follow an arbitrary argument but then that argument MUST ALWAYS be called as a keyword argument Note2: Other positional arguments may preceed an arbitrary argument Note3: An arbitrary argument CANNOT be called as a keyword argument! 1.3.6. Arbitrary Keyword Arguments(**kwargs): When an unknown or \"arbitrary\" number of keyword arguments are passed to a function, they are known as Arbitrary arguments def display_works ( author , ** works ): # works is a required argument. the ** denotes that it will accept an arbitrary number of keyword arguments. # works will be a dictionary of all the keyword arguments and their values provided. for key in works : print ( f \"( { key } , { works [ key ] } )\" ) print ( author ) display_works ( \"Roald Dahl\" , book1 = \"Charlie and the Chocolate Factory\" , book2 = \"Matilda\" ) Note1: No arguments can follow arbitrary keyword arguments. Note2: Any number of keyword or positional arguments can preceed arbitrary keyword arguments. def add_multiply ( * nums , multiply = 1 ): # nums is a required argument. the * denotes that it will accept an arbitrary number of arguments. # nums will be a list of all the arguments provided sum = 0 for num in nums : sum += num return sum * multiply # add up all these numbers print ( add_multiply ( 5 , 6 , 2 , 4 , 2 )) # prints 19 # add up all these numbers and also multiply by 2 print ( add_multiply ( 5 , 6 , 2 , 4 , 2 , 3 , 5 , multiply = 2 )) # prints 54","title":"1.3. Different types of arguments"},{"location":"Day_2/python%20oop/#14-type-hints","text":"When writing functions with a lot of parameters and variable names that might be unintuitive, it is a good idea to use type hints! type hints allow the person writing the function to tell the user what the expected data types of all the arguments being passed into it are For example: # this tells the user than height is a float, weight is an int and that this function is meant to return a float as well def calculateBMI ( height : float , weight : int ) -> float : return weight / (( height / 100 ) ** 2 ) print ( calculateBMI ( 182 , 80 ))","title":"1.4 Type Hints"},{"location":"Day_2/python%20oop/#15-what-is-recursion-and-why-do-we-need-it","text":"Lets take the factorial from the previous excersie as an example. We have learnt that n! = n*(n-1)*(n-2)*...*1 Similarly, (n-1)! = (n-1)*(n-2)*...*1 But, notice that from these two equations we can actually write that n! = n*(n-1)! So if you were being introduced to the factorial for the first time, and you were just told that n! = n*(n-1)! would this be enough information to find out the factorial of any number? Try computing 3! just by using the definition that n! = n*(n-1)!. If you actually tried to do that, you would realise that its actually not possible because with that definition, you don't know when to stop! 3! = 3*2! 2! = 2*1! 1! = 1*0! 0! = 0*(-1)! ... This means that other than the fact that n! = n*(n-1)! we also need a point to stop at. Lets say that you are now told that 0! = 1. With that information in mind, we can actually compute 3! 3! = 3*2! 2! = 2*1! 1! = 1*0! and now, we know that 0! = 1, so now we use that in the last equation and work our way back up! 1! = 1 and then using this, 2! = 2, and then using this, it is found that 3! = 6 This process of defining a process in its own terms is known as recursion! The \"stopping point\" at which we stop going down and start to work back up is known as the base case! So can we do something like this with functions? Yes! def factorial ( number ): # remember to write a base case! # If you forget, you're program will be stuck in an infinite loop of recursion! if number == 0 : return 1 # the recursive case: return number * factorial ( number - 1 )","title":"1.5 What is recursion, and why do we need it?"},{"location":"Day_2/python%20oop/#16-excersise-what-does-this-piece-of-code-output","text":"def function ( number ): if number >= 1 : print ( number ) function ( number - 1 ) print ( number ) function ( 3 ) Remember: A function will always execute ALL of its code UNLESS a return statement is encountered.","title":"1.6 Excersise: What does this piece of code output?"},{"location":"Day_2/python%20oop/#2-classes-and-objects","text":"","title":"2. Classes and Objects"},{"location":"Day_2/python%20oop/#21-what-is-object-oriented-programming-and-why-do-we-need-it","text":"We come across a lot of different objects in our daily life. Each object has its own properties, some features that define it. Lets take a pen for example. What are the properties of a pen? Its colour, its size, its kind (ball-point, fountain-point, gel-ink) and maybe the name of its owner. Another example is a textbook. A textbook has a size, it has a subject, it has a length (the number of pages) and it has some information inside of it. Now the information inside a textbook is organised into named chapters. For example, a maths text book might contain chapters like \"sets\", \"trigonometery\", \"calculus\" and so on, and if you want someone to read or go through a chapter, you'd say something like \"go through the chapter on calculus\". Now imagine that you are a programmer who wants to write code that describes a pen, or a textbook... how could you go about writing code that expresses these properties discussed above? You might try writing code that looks similar to this: pen_colour = \"red\" pen_size = 0.5 pen_kind = \"ball\" pen_owner = \"John\" # wouldn't you want a way to see the info about your pen? Lets write a function to do that! def display_information ( colour , size , kind , owner ): print ( \"Colour : \" + colour ) print ( \"Size : \" + str ( size )) print ( \"Kind : \" + kind ) print ( \"Owner : \" + owner ) print () display_information ( pen_colour , pen_size , pen_kind , pen_owner ) Sure, that would work for one pen, but some questions one might have are: What if you wanted to make an unknown number of pens? How would someone know how many variables to declare? What if you had a more complicated object with 100 properties? Would it be feasable to manually declare 100 variables for every object that you might need to create? This is where classes come into the picture. So far we have learnt about the primitive data types in python, primitive meaning that they are in-built, simple data types which python provides to us. Now we are moving on to custom data types, data types that are defined by you, the programmer!","title":"2.1. What is Object Oriented Programming, and why do we need it?"},{"location":"Day_2/python%20oop/#22-what-are-classes-and-why-do-we-need-them","text":"So now, we want to create our own data types, a data type that would allow us to describe a pen, or any other object effectively, using code. This is exactly what a class allows us to do! A class is basically a blue-print for creating an object, it tells us the defining properties of the object, and it also tells us what functions the object can perform. Following the class blue-print allows us to create \"instances\" of that class. An object of a class, the realisation of the blueprint, is known as an instance of the class. class Pen : # remember the properties of the pen we discussed? A colour, a size, a kind, an owner def __init__ ( pen , col , sz , knd , own ): pen . colour = col pen . size = sz pen . kind = knd pen . owner = own # This special function __init__ is known as a constructor, this is the \"method\" by which the object will be \"constructed\", # this is the essence of the blue-print! # wouldn't you want a way to see the properties of a pen you made as well? # you can write functions in a class that can work with the instances of the class. These functions are known as 'member # functions' of the class or 'methods'. # methods are always functions that work on objects of a specific class. A method cannot be used without an object # All methods of a class are unique to that class, and cannot be used on objects from other classes! # for example, you could have a method called read() that reads the contents of a text book but you # cannot use that method on a pen, because it doesn't make sense to read a pen! def display_information ( pen ): print ( \"Colour : \" + pen . colour ) print ( \"Size : \" + str ( pen . size )) print ( \"Kind : \" + pen . kind ) print ( \"Owner : \" + pen . owner ) print () # But a class is just a blue-print for creating a pen, it tells us which properties a pen is supposed to have # But it is NOT the pen itself! # To actually create a pen, we need to use the blue-print and specify all the properties of the specifc pen we want to create: A = Pen ( \"red\" , 0.5 , \"marker\" , \"John\" ) # When we do this, python calls the constructor and says, hey constructor, # construct me a Pen with its colour as \"red\", its size as 0.5, its kind as \"marker\" and let its owner be \"John\" # this process of creating an object from its class is known as instantiation A . display_information () # display this marker's information # And now that we actually have a pen class, remember that we can make AS MANY pens as we want! B = Pen ( \"blue\" , 0.1 , \"ball\" , \"John\" ) C = Pen ( \"black\" , 0.2 , \"fountain\" , \"Robin\" ) D = Pen ( \"red\" , 0.1 , \"gel\" , \"Joe\" ) E = Pen ( \"green\" , 0.1 , \"gel\" , \"Robert\" ) # since a method works on a particular instance of a class, it must be called by using the dot operator, on that specific object. B . display_information () C . display_information () D . display_information () E . display_information ()","title":"2.2. What are classes, and why do we need them?"},{"location":"Day_2/python%20oop/#23-classes-conventionally","text":"All programmers mutually agree to follow some rules, called conventions that are not necessary, but nice to follow while writing classes and make your code more readable to a usual programmer: class Pen : # typically, the object is called \"self\" in the functions that work with it # it is also common to give the same names to the function parameters as the properties of the object itself def __init__ ( self , colour , size , kind , owner ): self . colour = colour self . size = size self . kind = kind self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Size : \" + str ( self . size )) print ( \"Kind : \" + self . kind ) print ( \"Owner : \" + self . owner ) print ()","title":"2.3. Classes, conventionally"},{"location":"Day_2/python%20oop/#24-excersise-write-a-class-that-describes-a-bicycle-object","text":"Which properties should a bicycle object have? Colour (red, blue, white, etc) Material (steel, aluminum, plastic, wood, etc) Size (small, medium, large) Height of the seat (in m) Gear ratio (1, 2.5, 4, etc) Diameter of the wheels (in cm) Does it have a basket Does it have a Bell Do its wheels have sufficient air Is the chain of the bicycle routed properly What functions should a bicycle have? Change gear ratio Adjust seat height Route chain Pump air into the wheels Find the speed of the bicycle (in m/s) when a peddling speed (in rpm) is provided (Hint: The speed of a bicycle with a peddling speed in rpm is given by: (peddling_speed/60)*gear_ratio*((2*\u03c0*wheel_diameter/2)/100) ) Would you make this with or without using a class?","title":"2.4. Excersise: Write a class that describes a bicycle object"},{"location":"Day_2/python%20oop/#25-what-makes-classes-so-good","text":"Reusability: The same class can be used to make as many objects as you want Modularity: The code becomes incredibly modular, and it is easy for a programmer to debug the code in case there are any bugs Clarity of code: Due to the code being modular, it is easier for others to read and understand the code Better organisation: The data can be clearly and neatly organised for more complex objects Data Abstraction: This is the process of hiding the implementation details from the user, allowing them to focus on the functionality instead. Example: you don't need to know a smartphone works internally to be able to use it. The details about its circuits, its workings are hidden from you, the user! Instead, the smartphone provides you with functions (call, message, surf the internet) only. Example in python: The functions like math.sin() and math.cos() can be used to find out the sine or cosine of an angle, but they do not tell you how the calcualtion is actually done. Those implementation details are hidden from you, the user and you only need to focus on the functionality!","title":"2.5. What makes classes so good?"},{"location":"Day_2/python%20oop/#26-an-object-can-also-have-other-objects-as-its-properties","text":"class Pen : def __init__ ( self , colour , size , kind , owner ): self . colour = colour self . size = size self . kind = kind self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Size : \" + str ( self . size )) print ( \"Kind : \" + self . kind ) print ( \"Owner : \" + self . owner ) print () class Pencil : def __init__ ( self , colour , shade , owner ): self . colour = colour self . shade = shade self . owner = owner def display_information ( self ): print ( \"Colour : \" + self . colour ) print ( \"Shade : \" + str ( self . shade )) print ( \"Owner : \" + self . owner ) print () class Stationary : def __init__ ( self , pen , pencil ): self . pen = pen self . pencil = pencil def display_information ( self ): print ( \"The Pen: \" ) self . pen . display_information () print ( \"The Pencil: \" ) self . pencil . display_information () A = Stationary ( Pen ( \"blue\" , 0.1 , \"ball\" , \"John\" ), Pencil ( \"black\" , \"HB\" , \"John\" )) A . display_information ()","title":"2.6. An object can also have other objects as its properties"},{"location":"Day_2/python%20oop/#3-inheritance","text":"","title":"3. Inheritance"},{"location":"Day_2/python%20oop/#31-what-is-inheritance-and-why-do-we-need-it","text":"Lets say that there is a Person. Now each person has some defining properties, like their name, age, sex, height, weight. A person could be a student and in that case, they would have some additional defining properties, for example the school they attend, their id number, their year, their section and their seat number. Now imagine that you are a programmer trying to describe a student using code... how could you go about writing code that expresses these properties discussed above? Keep in mind that a class Person with the properties name, age, sex, height and weight already exists. You might think of a few different things that can be done here: One option is to have a person object as a part of the student object, like so: class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) class Student1 : def __init__ ( self , person , school , id_no , seat_no , year , section ): self . person = person self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): self . person . display_information () print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) print () A = Student1 ( Person ( \"John\" , 15 , \"male\" , 160 , 60 ), \"SUTD\" , 1024 , 32 , 2 , \"A\" ) print ( A . person . name + \"'s age: \" + str ( A . person . age )) A . display_information () Another option might be to declare all of the properties of a person again along with the additional properties of a student # class Person here is unused, basically making the already existing class redundant class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) class Student2 : def __init__ ( self , name , age , sex , height , weight , school , id_no , seat_no , year , section ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) print () # when there are a lot of function parameters, it is nice to specify which parameters correspond to what # values for better readability and clarity B = Student2 ( name = \"Robert\" , age = 14 , sex = \"male\" , height = 160 , weight = 65 , school = \"SUTD\" , id_no = 1025 , seat_no = 12 , year = 1 , section = \"A\" ) print ( B . name + \"'s age: \" + str ( B . age )) B . display_information () The first approach works, but the syntax looks a bit unintuitive, doesn't it? This is because to create a student object, you have to first make a Person object and then provide that person object to the student constructor, like so A = Student1(Person(\"John\", 15, \"male\", 170, 70), \"SUTD\", 1024, 32, 2, \"A\") Also, to access a student's name and age, you have to do A.person.name and A.person.age ... wouldn't A.name and A.age make more sense? The 2 nd approach fixes this issue but it is also a bit tedious because you have to manually declare all properties of a person inside the student constructor... What if there were not 5, but 100 different properties associated with a person? It would be too unfeasable to manually rewrite them. This is where inheritance comes into the picture. Inheritance literally allows us to \"inherit\" the properties of one class (called the super class) into another class (called the sub class) # Super/Parent class class Person : def __init__ ( self , name , age , sex , height , weight ): self . name = name self . age = age self . sex = sex self . height = height self . weight = weight def display_information ( self ): print ( \"Name : \" + self . name ) print ( \"Age : \" + str ( self . age )) print ( \"Sex : \" + self . sex ) print ( \"Height : \" + str ( self . height )) print ( \"Weight : \" + str ( self . weight )) # Base/Sub class class Student ( Person ): def __init__ ( self , name , age , sex , height , weight , school , id_no , seat_no , year , section ): Person . __init__ ( self , name , age , sex , height , weight ) self . school = school self . id_no = id_no self . seat_no = seat_no self . year = year self . section = section def display_information ( self ): Person . display_information ( self ) print ( \"School : \" + self . school ) print ( \"ID : \" + str ( self . id_no )) print ( \"Seat : \" + str ( self . seat_no )) print ( \"Year : \" + str ( self . year )) print ( \"Section : \" + self . section ) # when there are a lot of function parameters, it is nice to specify which parameters correspond to what # values for better readability and clarity A = Student ( name = \"Robin\" , age = 16 , sex = \"male\" , height = 180 , weight = 75 , school = \"SUTD\" , id_no = 1023 , seat_no = 3 , year = 3 , section = \"A\" ) print ( A . name + \"'s age: \" + str ( A . age )) A . display_information ()","title":"3.1. What is inheritance, and why do we need it?"},{"location":"Day_2/python%20oop/#32-excersise-given-a-class-computer-write-a-subclass-laptop-and-desktop-with-the-given-additional-properties","text":"A computer object has the following properties: CPU Type Storage Type Storage Quantity (in GB) RAM (in GB) GPU Type Write a class for laptop and desktop objecta that have the above properties, and the additional properties listed below: Desktop: Monitor Monitor Resolution Keyboard Mouse Laptop: Monitor Resolution is it a touchscreen? Also write a function that displays all this information class Computer : def __init__ ( self , cpu : str , storage_type : str , storage : float , ram : float , gpu : str ): # type hints can also be given to a class' data members self . cpu : str = cpu self . storage_type : str = storage_type self . storage : float = storage self . ram : float = ram self . gpu : str = gpu def display_information ( self ): print ( \"The CPU type is : \" + self . cpu ) print ( \"The Storage type is : \" + self . storage_type ) print ( \"The Stroage is : \" + str ( self . storage )) print ( \"The RAM is : \" + str ( self . ram )) print ( \"The GPU is : \" + self . gpu )","title":"3.2 Excersise: Given a class computer, Write a subclass laptop and desktop with the given additional properties:"},{"location":"Day_3/web_basics/","text":"Day 3 \u00b6 Overview \u00b6 Those who are new to programming may find it trivial to understand small lines of code, yet find difficulty in wrapping their heads around how applications, web applications in particular, work in general. This course was written to help the novice reader better understand, at least in abstract, how simple applications communicate and \"work\" over the internet. The intended outcome of this exercise is not for you to be able to understand the intricacies of transport layer protocols or how things work down to the wire, but to gain insight into the mental models of abstraction that allow us to understand the web. How does the web work? \u00b6 The fundamental question that underpins internet connected applications. Although it seems rather mysterious, the novice reader might do well to break the problem down . Then, they might find that their methods of inquiry are more effective than they would think. Indeed, this question, and the problem, is rather tractable even for beginners. We know that: data must be passed around from one remote computer to another. This data should be processed and results returned. So following which, we can setup the problem by asking the following questions: How do we retrieve and send information? What tools do we use to exchange information? How do these programs communicate? How do humans accomplish the tasks above? By answering any one of the questions above, we are able to get closer to a high-level understanding of how web applications works. Spoiler alert: By the end of your inquiries, you will come to the realization that what the web pretty much boils down to, is an exchange of information . Choosing what to do with the information is entirely up to us and is written in code. First, we need to figure out how to move this information around. How do we move information? \u00b6 Let's try to understand how information is being moved around and what we will need to make that exchange of information happen. Push or pull \u00b6 First, it's important for us to think about what moving information means. In general, we can think of moving information in terms of pushing and pulling . Pushing is when we would like to send information. Pulling is when we would like to receive information. We can think of the act of publishing an article as analogous to pushing information while reading an article is like pulling information. Similarly, when we post mail, we think: push. When we get mail, we think: pull. While in both ways information is being transferred, the directionality helps us understand which side of the exchange is likely intending to do more processing on the information. Request/Response \u00b6 An important concept in programming is the idea of requests and responses. To initiate an exchange of information, first there must be some request for information followed by a response that finalizes the exchange. Simply: A request is a question and a response is an answer. The answer may have useful information or it may not. Some requests may not get an answer\u2026 in which case we say that the requested resource is not found . It is also helpful to understand requests as capable of being both push and pull . Rather, the requests that we think as analogous to questions, can be both asking for information and also sending information . So they are not questions in the sense that they always ask for information, but more like questions in the sense that they initiate an exchange of information from one person to another, in either direction. ** Pull ** Person A: How many books are in the library? Person B: 23. ** Push ** Person A: I'd like to donate this book to the library. Person B: Okay, we will accept it. What makes a request? \u00b6 Not all requests look like this, but for the sake of simplicity, we will be looking at RESTful HTTP requests. We can break down the parts of request as follows: Type The request type is just a way of categorizing requests according to function. It is helpful to know the request type because it will help us understand the purpose of the request. GET - used when pulling information POST - used when pushing information PUT - pushing , but with the intent to update existing information DELETE - pushing , but with the intent to delete existing information \\ You may notice that POST, GET, PUT, DELETE follow the CREATE, READ, UPDATE, DELETE (CRUD) paradigm. URL The URL is a string that contains information about the request. You can think of the URL as a house address on steroids. It is a way to locate the address of the receiver, transmit information about how to transport the data and even what to do with the request. Scheme - HTTP/HTTPS is how the request is transported Domain - youtube.com is the address of the recipient Path - /search tells us the unit number of the receiver Query Parameters - ?query=dog+videos data (we'll cover this later) Payload The data we are sending across Responses \u00b6 We note that responses are tied to a request. Meaning that while responses also carry information, they are not \u201cpush\u201d requests; you do not initiate a response the same way you initiate a request. It is useful to think of it that once a request is sent, it \u201cpicks up\u201d the response on its way back to the computer who initiated it. Responses, like requests, also contain information. Status Codes They give us semantic information about a request. Whether a request succeeds, fails, whether there was an error, a request was malformed or even if the resource being requested for is not found. Assuming the server provides accurate status codes, we can use this in our code logic to decide whether or not to take a certain action, retry the request or abort the operation. Payload Like requests, responses can contain data being returned to the client who initiated the request. This must be so- when we make a GET request, don't we want to receive information in return? What is HTML/CSS? \u00b6 According to W3C : HTML (the Hypertext Markup Language) and CSS (Cascading Style Sheets) are two of the core technologies for building Web pages. HTML provides the structure of the page, CSS the (visual and aural) layout, for a variety of devices. Along with graphics and scripting, HTML and CSS are the basis of building Web pages and Web Applications. Simply put, HTML contains the instructions on how to structure a web page and CSS provides information on styling (eg. colour, width, height...). Putting it all together \u00b6 Now that we understand request/responses, we can roughly see how a web browser works. A web browser, is like a graphical user interface (GUI) for making requests over the internet! Browser makes a GET request for https://www.youtube.com Youtube's servers return HTML, Javascript and CSS for the front page. Browser loads the HTML, Javascript and CSS. Voila, you see the frontpage.","title":"Web Basics"},{"location":"Day_3/web_basics/#day-3","text":"","title":"Day 3"},{"location":"Day_3/web_basics/#overview","text":"Those who are new to programming may find it trivial to understand small lines of code, yet find difficulty in wrapping their heads around how applications, web applications in particular, work in general. This course was written to help the novice reader better understand, at least in abstract, how simple applications communicate and \"work\" over the internet. The intended outcome of this exercise is not for you to be able to understand the intricacies of transport layer protocols or how things work down to the wire, but to gain insight into the mental models of abstraction that allow us to understand the web.","title":"Overview"},{"location":"Day_3/web_basics/#how-does-the-web-work","text":"The fundamental question that underpins internet connected applications. Although it seems rather mysterious, the novice reader might do well to break the problem down . Then, they might find that their methods of inquiry are more effective than they would think. Indeed, this question, and the problem, is rather tractable even for beginners. We know that: data must be passed around from one remote computer to another. This data should be processed and results returned. So following which, we can setup the problem by asking the following questions: How do we retrieve and send information? What tools do we use to exchange information? How do these programs communicate? How do humans accomplish the tasks above? By answering any one of the questions above, we are able to get closer to a high-level understanding of how web applications works. Spoiler alert: By the end of your inquiries, you will come to the realization that what the web pretty much boils down to, is an exchange of information . Choosing what to do with the information is entirely up to us and is written in code. First, we need to figure out how to move this information around.","title":"How does the web work?"},{"location":"Day_3/web_basics/#how-do-we-move-information","text":"Let's try to understand how information is being moved around and what we will need to make that exchange of information happen.","title":"How do we move information?"},{"location":"Day_3/web_basics/#push-or-pull","text":"First, it's important for us to think about what moving information means. In general, we can think of moving information in terms of pushing and pulling . Pushing is when we would like to send information. Pulling is when we would like to receive information. We can think of the act of publishing an article as analogous to pushing information while reading an article is like pulling information. Similarly, when we post mail, we think: push. When we get mail, we think: pull. While in both ways information is being transferred, the directionality helps us understand which side of the exchange is likely intending to do more processing on the information.","title":"Push or pull"},{"location":"Day_3/web_basics/#requestresponse","text":"An important concept in programming is the idea of requests and responses. To initiate an exchange of information, first there must be some request for information followed by a response that finalizes the exchange. Simply: A request is a question and a response is an answer. The answer may have useful information or it may not. Some requests may not get an answer\u2026 in which case we say that the requested resource is not found . It is also helpful to understand requests as capable of being both push and pull . Rather, the requests that we think as analogous to questions, can be both asking for information and also sending information . So they are not questions in the sense that they always ask for information, but more like questions in the sense that they initiate an exchange of information from one person to another, in either direction. ** Pull ** Person A: How many books are in the library? Person B: 23. ** Push ** Person A: I'd like to donate this book to the library. Person B: Okay, we will accept it.","title":"Request/Response"},{"location":"Day_3/web_basics/#what-makes-a-request","text":"Not all requests look like this, but for the sake of simplicity, we will be looking at RESTful HTTP requests. We can break down the parts of request as follows: Type The request type is just a way of categorizing requests according to function. It is helpful to know the request type because it will help us understand the purpose of the request. GET - used when pulling information POST - used when pushing information PUT - pushing , but with the intent to update existing information DELETE - pushing , but with the intent to delete existing information \\ You may notice that POST, GET, PUT, DELETE follow the CREATE, READ, UPDATE, DELETE (CRUD) paradigm. URL The URL is a string that contains information about the request. You can think of the URL as a house address on steroids. It is a way to locate the address of the receiver, transmit information about how to transport the data and even what to do with the request. Scheme - HTTP/HTTPS is how the request is transported Domain - youtube.com is the address of the recipient Path - /search tells us the unit number of the receiver Query Parameters - ?query=dog+videos data (we'll cover this later) Payload The data we are sending across","title":"What makes a request?"},{"location":"Day_3/web_basics/#responses","text":"We note that responses are tied to a request. Meaning that while responses also carry information, they are not \u201cpush\u201d requests; you do not initiate a response the same way you initiate a request. It is useful to think of it that once a request is sent, it \u201cpicks up\u201d the response on its way back to the computer who initiated it. Responses, like requests, also contain information. Status Codes They give us semantic information about a request. Whether a request succeeds, fails, whether there was an error, a request was malformed or even if the resource being requested for is not found. Assuming the server provides accurate status codes, we can use this in our code logic to decide whether or not to take a certain action, retry the request or abort the operation. Payload Like requests, responses can contain data being returned to the client who initiated the request. This must be so- when we make a GET request, don't we want to receive information in return?","title":"Responses"},{"location":"Day_3/web_basics/#what-is-htmlcss","text":"According to W3C : HTML (the Hypertext Markup Language) and CSS (Cascading Style Sheets) are two of the core technologies for building Web pages. HTML provides the structure of the page, CSS the (visual and aural) layout, for a variety of devices. Along with graphics and scripting, HTML and CSS are the basis of building Web pages and Web Applications. Simply put, HTML contains the instructions on how to structure a web page and CSS provides information on styling (eg. colour, width, height...).","title":"What is HTML/CSS?"},{"location":"Day_3/web_basics/#putting-it-all-together","text":"Now that we understand request/responses, we can roughly see how a web browser works. A web browser, is like a graphical user interface (GUI) for making requests over the internet! Browser makes a GET request for https://www.youtube.com Youtube's servers return HTML, Javascript and CSS for the front page. Browser loads the HTML, Javascript and CSS. Voila, you see the frontpage.","title":"Putting it all together"},{"location":"Day_4/server_basics/","text":"Day 4 \u00b6 Now that we roughly understand how applications interact over the internet, we might also want to understand how these applications are able to run, on what hardware and also find out what servers exactly are. What are servers? \u00b6 Let me quickly dissipate any confusion as to what servers might/might not be. They are computers. Whenever someone uses the term servers what they really mean is a computer is doing the work. then why call them servers? The main difference between servers and computers is that the former is assumed to not have any graphical interface to interact with- it is just the computer hardware but without the screen. Of course, there are other nuances but we will not delve into that. For now, just understand that servers are really also just computers. Both will take in the same code and punch out the same information. How do application backends work? \u00b6 When we use the term backend , we refer to the computational logic that processes data. Conversely, frontend refers to the display of data to the end-user through HTML, CSS, and Javascript. So to understand how application backends work, we might want to answer the following questions: How do they parse requests? Where does information get stored? How do we retrieve this information? Essentially what\u2019s happening is that your app server \u201clistens on a port for incoming activity. When it does receive a request, it takes the data and does some processing and returns the response. A-ha! I used a new word here, port . What is a port? It might be helpful to think about USB-ports, shipping ports, and all sorts of ports to kind of grapple with what it is. Where does information get stored? \u00b6 When we write code, sometimes we store data in variables. a = 1 In this case, the computer stores the relation of a holding the value of 1 in memory. When we end the program, or shut the computer down, the memory is cleared and we lose the information. For applications like Facebook, Netflix, and many more, it is thus important to have some kind of persistent storage of information that will be able to keep our data safe, secure and available for use the next time we access the application. We call these data stores databases . Databases are collections of information that allow you to store, update, delete and manage data. When we write information to a database, this database is assumed to be sitting in some server, and the information we store in it is not stored in memory but actually written to disk. Think about it like saving a file to your Desktop. The file is written to your hard disk so that on bootup, the data will still be available. Types of databases \u00b6 There are many types of databases. The two common ways to delineate databases is: SQL and NoSQL. Specifically, relational and non-relational databases. In a relational database, information is stored in tables, neatly structured in terms of rows and columns. Much like Excel spreadsheets, the data relates to each other through their attributes. id Name Gender 1 Raphael M 2 Alex F 3 Ben NA In a non-relational database, information is stored in nestable, key-value pairs. Much like Python's dictionaries. A document database looks very much like JSON. Instead of tables and rows, we have nested \u201cdictionary\u201d-like structures that allow us to query for data using key-values. { users: [ { id: 1, first_name: Ben, last_name: Bitdiddle, Gender: M }, { id: 2, first_name: Alyssa P., last_name: Hacker, Gender: F }, ] } What is deployment? \u00b6 After writing a piece of software, your app is available locally on your computer. But what if you want it to be available over the internet? Deployment is the process of putting your app on cloud servers, allowing your app to be accessed over the internet. Once deployed, your application is able to receive requests over the web! Common cloud-providers are AWS, Microsoft Azure, Google Cloud Platform, Heroku, DigitalOcean, and more. All of them help you manage the hardware servers that will host your application so that you only have to worry about your code.","title":"Server Basics"},{"location":"Day_4/server_basics/#day-4","text":"Now that we roughly understand how applications interact over the internet, we might also want to understand how these applications are able to run, on what hardware and also find out what servers exactly are.","title":"Day 4"},{"location":"Day_4/server_basics/#what-are-servers","text":"Let me quickly dissipate any confusion as to what servers might/might not be. They are computers. Whenever someone uses the term servers what they really mean is a computer is doing the work. then why call them servers? The main difference between servers and computers is that the former is assumed to not have any graphical interface to interact with- it is just the computer hardware but without the screen. Of course, there are other nuances but we will not delve into that. For now, just understand that servers are really also just computers. Both will take in the same code and punch out the same information.","title":"What are servers?"},{"location":"Day_4/server_basics/#how-do-application-backends-work","text":"When we use the term backend , we refer to the computational logic that processes data. Conversely, frontend refers to the display of data to the end-user through HTML, CSS, and Javascript. So to understand how application backends work, we might want to answer the following questions: How do they parse requests? Where does information get stored? How do we retrieve this information? Essentially what\u2019s happening is that your app server \u201clistens on a port for incoming activity. When it does receive a request, it takes the data and does some processing and returns the response. A-ha! I used a new word here, port . What is a port? It might be helpful to think about USB-ports, shipping ports, and all sorts of ports to kind of grapple with what it is.","title":"How do application backends work?"},{"location":"Day_4/server_basics/#where-does-information-get-stored","text":"When we write code, sometimes we store data in variables. a = 1 In this case, the computer stores the relation of a holding the value of 1 in memory. When we end the program, or shut the computer down, the memory is cleared and we lose the information. For applications like Facebook, Netflix, and many more, it is thus important to have some kind of persistent storage of information that will be able to keep our data safe, secure and available for use the next time we access the application. We call these data stores databases . Databases are collections of information that allow you to store, update, delete and manage data. When we write information to a database, this database is assumed to be sitting in some server, and the information we store in it is not stored in memory but actually written to disk. Think about it like saving a file to your Desktop. The file is written to your hard disk so that on bootup, the data will still be available.","title":"Where does information get stored?"},{"location":"Day_4/server_basics/#types-of-databases","text":"There are many types of databases. The two common ways to delineate databases is: SQL and NoSQL. Specifically, relational and non-relational databases. In a relational database, information is stored in tables, neatly structured in terms of rows and columns. Much like Excel spreadsheets, the data relates to each other through their attributes. id Name Gender 1 Raphael M 2 Alex F 3 Ben NA In a non-relational database, information is stored in nestable, key-value pairs. Much like Python's dictionaries. A document database looks very much like JSON. Instead of tables and rows, we have nested \u201cdictionary\u201d-like structures that allow us to query for data using key-values. { users: [ { id: 1, first_name: Ben, last_name: Bitdiddle, Gender: M }, { id: 2, first_name: Alyssa P., last_name: Hacker, Gender: F }, ] }","title":"Types of databases"},{"location":"Day_4/server_basics/#what-is-deployment","text":"After writing a piece of software, your app is available locally on your computer. But what if you want it to be available over the internet? Deployment is the process of putting your app on cloud servers, allowing your app to be accessed over the internet. Once deployed, your application is able to receive requests over the web! Common cloud-providers are AWS, Microsoft Azure, Google Cloud Platform, Heroku, DigitalOcean, and more. All of them help you manage the hardware servers that will host your application so that you only have to worry about your code.","title":"What is deployment?"},{"location":"Day_5/intro_to_linux/","text":"Day 5: Introduction to Linux & Shell \u00b6 Date: 09 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction Linux (Ubuntu) Introduction to UNIX Shell Introduction to SSH Introduction to Dotfiles Management UNIX Shell Preparation \u00b6 For Windows User: Enable and install Windows Subsystem for Linux 2 (WSL 2) , you may choose Ubuntu 20.04 LTS as your Linux distro choice. For macOS User: Download and install iTerm2","title":"Intro to Linux"},{"location":"Day_5/intro_to_linux/#day-5-introduction-to-linux-shell","text":"Date: 09 Feb 2021 (Tuesday) Time: 6.30pm - 10.30pm Venue: SUTD i3 Lab (1.605) Online Venue: Twitch Introduction Linux (Ubuntu) Introduction to UNIX Shell Introduction to SSH Introduction to Dotfiles Management UNIX Shell","title":"Day 5: Introduction to Linux &amp; Shell"},{"location":"Day_5/intro_to_linux/#preparation","text":"For Windows User: Enable and install Windows Subsystem for Linux 2 (WSL 2) , you may choose Ubuntu 20.04 LTS as your Linux distro choice. For macOS User: Download and install iTerm2","title":"Preparation"}]}